<!DOCTYPE html>
<html lang="tr" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title data >üéµ Gharmonize</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title-section">
        <h1 data >üéµ Gharmonize</h1>
        <p class="subtitle" data-i18n="app.subtitle">Linkten sese, tek tƒ±k: Gharmonize.</p>
      </div>
      <div class="lang-toggle">
          <button type="button" class="btn-outline" data-lang="tr">TR</button>
          <button type="button" class="btn-outline" data-lang="en">EN</button>
          <button type="button" class="btn-outline" data-lang="de">DE</button>
          <button type="button" class="btn-outline" data-lang="fr">FR</button>
      </div>
      <div class="theme-toggle" id="themeToggle">
        <span class="theme-icon">üåô</span>
        <div class="toggle-switch"></div>
        <span class="theme-icon">‚òÄÔ∏è</span>
      </div>
        <button id="settingsBtn" class="btn-outline" data-i18n-title="btn.envSettings">‚öôÔ∏è</button>
        <button id="jobsBell" class="jobs-bell" title="Aktif i≈üler" hidden>
          <span class="bell-icon">üîî</span>
          <span id="jobsBadge" class="jobs-badge" hidden>0</span>
        </button>
    </div>
    <div class="card-grid">
      <div class="card">
        <h2 data-i18n="section.output">‚öôÔ∏è √áƒ±ktƒ± Ayarlarƒ±</h2>
        <div class="form-group">
          <label data-i18n="label.format">Format:</label>
          <select id="formatSelect"></select>
        </div>
        <div class="form-group">
          <label data-i18n="label.quality">Kalite:</label>
          <select id="bitrateSelect"></select>
        </div>
        <div class="form-group">
          <label data-i18n="label.sampleRate">√ñrnekleme Hƒ±zƒ±:</label>
          <select id="sampleRateSelect">
            <option value="44100" data-i18n="quality.44100">44.1 kHz (CD Kalitesi)</option>
            <option value="48000" selected data-i18n="quality.48000">48 kHz (Standart)</option>
            <option value="96000" data-i18n="quality.96000">96 kHz (Y√ºksek Kalite)</option>
            <option value="192000" data-i18n="quality.192000">192 kHz (St√ºdyo Kalitesi)</option>
          </select>
        </div>
      </div>
      <div class="card">
        <h2 data-i18n="section.url">üîó URL'den D√∂n√º≈üt√ºr</h2>
        <form id="urlForm">
          <div class="form-group">
            <input type="url" id="urlInput" data-i18n-ph="ph.url" placeholder="YouTube URL veya doƒürudan medya linki" required />
          </div>
          <div class="checkbox-group" id="playlistCheckboxContainer">
            <input type="checkbox" id="playlistCheckbox" />
            <label for="playlistCheckbox" data-i18n="label.playlist">Bu bir YouTube playlist'i</label>
          </div>
           <div class="checkbox-group" id="lyricsCheckboxContainer">
       <input type="checkbox" id="lyricsCheckbox" />
       <label for="lyricsCheckbox" data-i18n="label.includeLyrics">≈ûarkƒ± s√∂zlerini dahil et</label>
     </div>
          <div class="spotify-actions" id="urlSpotifyActions" style="display: none;">
              <button id="startSpotifyBtn" class="btn-primary" data-i18n="btn.spotifyPreview">Spotify E≈üle≈ütirmeyi Ba≈ülat</button>
              <button id="startIntegratedBtn" class="btn-primary" data-i18n="btn.spotifyIntegrated">E≈üle≈ütir ve ƒ∞ndir</button>
          </div>
          <div class="btn-row" id="normalUrlActions">
            <button type="submit" id="startConvertBtn" data-i18n="btn.start">
              <span class="btn-spinner" style="display: none;"></span>
              <span class="btn-text">D√∂n√º≈üt√ºrmeyi Ba≈ülat</span>
            </button>
            <button type="button" class="btn-outline" id="previewBtn" data-i18n="btn.preview" data-i18n-title="btn.preview" title="Playlist'i √ñnizle">Playlist'i √ñnizle</button>
          </div>
        </form>
      </div>
      <div class="card">
        <h2 data-i18n="section.file">üìÅ Dosya Y√ºkle</h2>
        <form id="fileForm" enctype="multipart/form-data">
          <div class="form-group">
            <input type="file" id="fileInput" accept="video/*,audio/*" required />
          </div>
          <button type="submit" data-i18n="btn.upload">Y√ºkle ve D√∂n√º≈üt√ºr</button>
        </form>
      </div>
    </div>
    <div class="card collapsible-section" id="spotifyPreviewCard" style="display: none;">
      <div class="collapsible-header" id="spotifyPreviewHeader">
        <h2 data-i18n="section.spotifyPreview">üéµ Spotify E≈üle≈ütirme</h2>
        <span class="toggle-arrow">‚ñº</span>
      </div>
      <div class="collapsible-content" id="spotifyPreviewContent">
        <div class="collapsible-inner">
      <div class="preview-meta">
        <span class="chip"><span data-i18n="chip.title">Ba≈ülƒ±k:</span> <strong id="spotifyTitle">-</strong></span>
        <span class="chip"><span data-i18n="chip.total">Toplam:</span> <strong id="spotifyTotal">0</strong></span>
        <span class="chip"><span data-i18n="chip.matched">E≈üle≈üen:</span> <strong id="spotifyMatched">0</strong></span>
        <span class="chip"><span data-i18n="chip.progress">ƒ∞lerleme:</span> <strong id="spotifyProgress">0%</strong></span>
      </div>
      <div class="spotify-actions" id="spotifyActions">
        <button id="convertMatchedBtn" class="btn-primary" style="display: none;" data-i18n="btn.convertMatched">E≈üle≈üenleri D√∂n√º≈üt√ºr</button>
      </div>
      <div id="spotifyStatus" class="spotify-job-status" style="display: none; margin-top: 10px;">
        <span id="spotifyStatusText" data-i18n="status.ready">Hazƒ±r</span>
      </div>
      <div class="logs-container">
        <h3 data-i18n="section.logs">üìù Ger√ßek Zamanlƒ± Loglar</h3>
        <div id="spotifyLogs" class="logs-content"></div>
      </div>
      <div class="preview-list-container">
        <h3 data-i18n="section.matchedTracks">üé∂ E≈üle≈üen Par√ßalar</h3>
        <div class="preview-list" id="spotifyPreviewList"></div>
        </div>
      </div>
    </div>
  </div>
    <div class="card collapsible-section" id="playlistPreviewCard" style="display: none;">
      <div class="collapsible-header" id="playlistPreviewHeader">
        <h2 data-i18n="section.preview">üßæ Playlist √ñnizleme ve Se√ßim</h2>
        <span class="toggle-arrow">‚ñº</span>
      </div>
      <div class="collapsible-content" id="playlistPreviewContent">
        <div class="collapsible-inner">
      <div class="preview-meta">
        <span class="chip"><span data-i18n="chip.title">Ba≈ülƒ±k:</span> <strong id="plTitle">-</strong></span>
        <span class="chip"><span data-i18n="chip.total">Toplam:</span> <strong id="plCount">0</strong></span>
        <span class="chip"><span data-i18n="chip.selected">Se√ßili:</span> <strong id="plSelected">0</strong></span>
      </div>
      <div class="preview-actions">
        <label class="select-all"><input type="checkbox" id="selectAllChk" /> <span data-i18n="label.selectAll">Hepsini se√ß</span></label>
        <label class="switch">
          <input type="checkbox" id="sequentialChk" />
          <span class="muted" data-i18n="label.sequential">Tek tek indir</span>
        </label>
        <button id="convertSelectedBtn" data-i18n="btn.convertSelected">Se√ßilenleri D√∂n√º≈üt√ºr</button>
        <button class="btn-outline" id="convertAllBtn" data-i18n="btn.convertAll">T√ºm√ºn√º D√∂n√º≈üt√ºr</button>
      </div>
      <div id="plStreamLog" class="muted" style="margin:6px 0 0 0; font-size:12px; display:none;"></div>
      <div class="pager">
        <button id="prevPageBtn" class="btn-outline" data-i18n="pager.prev">‚Üê √ñnceki</button>
        <button id="nextPageBtn" class="btn-outline" data-i18n="pager.next">Sonraki ‚Üí</button>
        <span class="muted"><span data-i18n="pager.page">Sayfa:</span> <strong id="pageNo">1</strong> ‚Ä¢ <span data-i18n="pager.size">Sayfa boyutu:</span> </span>
        <select id="pageSizeSel" class="inline">
          <option>10</option>
          <option>25</option>
          <option selected>50</option>
          <option>100</option>
        </select>
      </div>
      <div class="preview-list" id="previewList"></div>
      </div>
    </div>
  </div>

    <div class="card collapsible-section">
      <div class="collapsible-header" id="jobsHeader">
        <h2 data-i18n="section.jobs">üìä Aktif ƒ∞≈üler</h2>
        <span class="toggle-arrow">‚ñº</span>
      </div>
        <div class="collapsible-content" id="jobsContent">
          <div class="collapsible-inner">
              <div id="jobList">
                <div class="job-item" id="job-empty">
                      <div class="jobs-empty-state">
                      <div class="jobs-empty-icon">üéµ</div>
                        <h3 class="jobs-empty-title" data-i18n="jobsPanel.emptyActive">Hen√ºz i≈ü yok</h3>
                      <p class="jobs-empty-subtitle" data-i18n="jobs.emptySubtitle">Bir URL ekleyerek veya dosya y√ºkleyerek d√∂n√º≈ü√ºme ba≈ülayƒ±n</p>
                    <div class="jobs-empty-actions">
                  <button class="jobs-empty-action" onclick="focusUrlInput()" data-i18n="jobs.startWithUrl">URL ile Ba≈üla</button>
              <button class="jobs-empty-action jobs-empty-action--outline" onclick="focusFileInput()" data-i18n="section.file">Dosya Y√ºkle</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
</div>

  <aside id="jobsPanel" class="jobs-panel" aria-hidden="true">
    <header class="jobs-panel__header">
      <div class="title" data-i18n="jobsPanel.title">Aktif ƒ∞≈üler</div>
      <div class="controls">
        <button id="jobsFilterActive" class="chip chip--active" data-filter="active" data-i18n="jobsPanel.filterActive">Aktif</button>
        <button id="jobsFilterAll" class="chip" data-filter="all" data-i18n="jobsPanel.filterAll">T√ºm√º</button>
        <button id="jobsClose" class="icon-btn" aria-label="Kapat" data-i18n="btn.close">‚úï</button>
      </div>
    </header>
    <div id="jobsList" class="jobs-list">
      <div class="jobs-panel__empty" id="jobsPanelEmpty">
        <div class="jobs-panel__empty-icon">üéµ</div>
        <div class="jobs-panel__empty-title">Hen√ºz i≈ü yok</div>
        <div class="jobs-panel__empty-subtitle">D√∂n√º≈üt√ºrme i≈ülemleri burada g√∂r√ºnecek. Hemen ba≈ülamak i√ßin bir URL ekleyin veya dosya y√ºkleyin.</div>
        <div class="jobs-panel__empty-actions">
          <button class="jobs-panel__empty-action" onclick="focusUrlInputAndClose()">URL Ekle</button>
          <button class="jobs-panel__empty-action jobs-panel__empty-action--outline" onclick="focusFileInputAndClose()">Dosya Se√ß</button>
        </div>
      </div>
    </div>
  </aside>
  <div id="jobsOverlay" class="jobs-overlay" hidden></div>

<script src="/i18n.js"></script>
  <script>

  document.addEventListener('DOMContentLoaded', function() {
      function setupCollapsible(headerId, contentId) {
        const header = document.getElementById(headerId);
        const content = document.getElementById(contentId);

        if (header && content) {
          header.addEventListener('click', function() {
            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
          });
        }
      }

      setupCollapsible('spotifyPreviewHeader', 'spotifyPreviewContent');
      setupCollapsible('playlistPreviewHeader', 'playlistPreviewContent');
      setupCollapsible('jobsHeader', 'jobsContent');

      const jobsHeader = document.getElementById('jobsHeader');
      const jobsContent = document.getElementById('jobsContent');
      if (jobsHeader && jobsContent) {
        jobsHeader.classList.remove('collapsed');
        jobsContent.classList.remove('collapsed');
      }
    });

  function focusUrlInput() {
      const urlInput = document.getElementById('urlInput');
      if (urlInput) {
        urlInput.focus();
        urlInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    function focusFileInput() {
      const fileInput = document.getElementById('fileInput');
      if (fileInput) {
        fileInput.click();
        fileInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    function focusUrlInputAndClose() {
      focusUrlInput();
      closeJobsPanel();
    }

    function focusFileInputAndClose() {
      focusFileInput();
      closeJobsPanel();
    }

    function closeJobsPanel() {
      const panel = document.getElementById('jobsPanel');
      const overlay = document.getElementById('jobsOverlay');
      if (panel) panel.setAttribute('aria-hidden', 'true');
      if (overlay) overlay.hidden = true;
    }

    function isSpotifyUrl(u){
      return /^(https?:\/\/open\.spotify\.com|spotify:)/i.test(String(u||""));
    }

    function toRelative(u) {
      if (!u) return u;
      try {
        const url = new URL(u, location.origin);
        if (url.origin === location.origin) {
          return url.pathname + url.search + url.hash;
        }
        return u;
      } catch {
        return u.replace(/^https?:\/\/[^/]+/i, '');
      }
    }

class NotificationManager {
    constructor() {
        this.notificationQueue = new Map();
        this.activeNotifications = new Set();
        this.notificationTimers = new Map();
    }

    showNotification(message, type = 'info', group = 'default', duration = 3000) {
        if (this.notificationTimers.has(group)) {
            clearTimeout(this.notificationTimers.get(group));
            this.notificationTimers.delete(group);
        }

        if (this.activeNotifications.has(group)) {
            const existing = document.querySelector(`[data-notification-group="${group}"]`);
            if (existing) {
                existing.remove();
                this.activeNotifications.delete(group);
            }
        }

        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        notification.setAttribute('data-notification-group', group);

        notification.style.transform = 'translateX(100%)';
        notification.style.opacity = '0';
        notification.style.transition = 'all 0.3s ease';

        document.body.appendChild(notification);

        this.activeNotifications.add(group);

        requestAnimationFrame(() => {
            notification.style.transform = 'translateX(0)';
            notification.style.opacity = '1';
        });

        const timer = setTimeout(() => {
            this.hideNotification(notification, group);
        }, duration);

        this.notificationTimers.set(group, timer);
    }

    hideNotification(notification, group) {
        notification.style.transform = 'translateX(100%)';
        notification.style.opacity = '0';

        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
            this.activeNotifications.delete(group);
            this.notificationTimers.delete(group);
        }, 300);
    }

    quickNotify(message, type = 'info', group = 'default') {
        this.showNotification(message, type, group, 2000);
    }

    clearAll() {
        document.querySelectorAll('.notification').forEach(notification => {
            notification.remove();
        });
        this.activeNotifications.clear();
        this.notificationTimers.forEach(timer => clearTimeout(timer));
        this.notificationTimers.clear();
    }
}

const notificationManager = new NotificationManager();

    class MediaConverterApp {
    constructor() {
        this.currentJobs = new Map();
        this._escapeMap = {
        '&': '&amp;', '<': '&lt;', '>': '&gt;',
        '"': '&quot;', "'": '&#39;', '`': '&#96;', '=': '&#61;', '/': '&#47;'
        };
        this.includeLyrics = false;
        this.currentSampleRate = 48000;
        this.currentPreview = {
          url: null, items: [], selected: new Set(),
          title: '', count: 0, page: 1, pageSize: 25,
          isSpotify: false, streaming: false,
          indexToId: new Map(),
          indexToTitle: new Map()
        };
        this.currentSpotifyTask = {
          id: null,
          jobId: null,
          completed: false
        };
        this.integratedRenderedCount = 0;
        this.batches = new Map();
        this.jobToBatch = new Map();
        this.jobStates = new Map();
        this.previewAbort = null;
        this.spotifyEventSource = null;
        this.notificationManager = notificationManager;
        this.initializeEventListeners();
        this.toRelative = (u) => {
          try {
            return toRelative(u);
          } catch { return u; }
        };
        this.initializeTheme();
        this.loadFormats();
        this.ensureWarnStyles();
      }

      ensureWarnStyles() {
        if (document.getElementById('skipped-badge-style')) return;
        const st = document.createElement('style');
        st.id = 'skipped-badge-style';
      }

      computeSkipped(job) {
      const fromStats = Number(job?.metadata?.skipStats?.skippedCount);
  if (Number.isFinite(fromStats) && fromStats >= 0) return fromStats;
  const direct = Number(job?.skippedCount ?? job?.metadata?.skippedCount);
  if (Number.isFinite(direct) && direct >= 0) return direct;

      if (Number.isFinite(job?.playlist?.skipped)) {
        return Number(job.playlist.skipped);
      }

      if (Number.isFinite(job?.errorsCount)) {
        return Number(job.errorsCount);
      }

      if (job?.metadata?.isPlaylist && Array.isArray(job?.resultPath)) {
        const successful = job.resultPath.filter(r => r && r.outputPath && !r.error).length;
        const total = Number(job?.playlist?.total ?? job?.metadata?.frozenEntries?.length ?? successful);
        return Math.max(0, Math.min(total, total - successful));
      }

      if (job?.stderr) {
        const skipPattern = /(private|izin|skipp?ed|unavailable|atlan(?:d|an)|blocked|copyright|region|geo)/gi;
        const matches = job.stderr.match(skipPattern);
        return matches ? matches.length : 0;
      }

      return 0;
      }

      normalizeStatus(s) {
      const v = String(s || '').toLowerCase();
      return v === 'cancelled' ? 'canceled' : v;
    }

      initializeTheme() {
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);

        const themeToggle = document.getElementById('themeToggle');
        themeToggle.addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme');
          const newTheme = currentTheme === 'light' ? 'dark' : 'light';
          document.documentElement.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }

      async loadFormats() {
        try {
          const response = await fetch('/api/formats');
          const data = await response.json();
          this.updateFormatOptions(data.formats);
          this.handleFormatChange();
        }
        catch (error) {
          console.error('Formatlar y√ºklenemedi:', error);
        }
      }

      handleFormatChange() {
        const formatSelect = document.getElementById('formatSelect');
        formatSelect.addEventListener('change', async (e) => {
        const format = e.target.value;
        this.toggleFormatSpecificOptions(format);

        const formats = await this.getFormats();
        this.updateBitrateOptions(format, formats);
      });

        const currentFormat = formatSelect.value;
        this.toggleFormatSpecificOptions(currentFormat);
      }

      toggleFormatSpecificOptions(format) {
        const sampleRateGroup = document.querySelector('.form-group:has(#sampleRateSelect)');
        const lyricsGroup = document.getElementById('lyricsCheckboxContainer');
        const isMp4 = format === 'mp4';

        if (sampleRateGroup) {
          sampleRateGroup.style.display = isMp4 ? 'none' : '';
        }

        if (lyricsGroup) {
          lyricsGroup.style.display = isMp4 ? 'none' : '';
        }
      }

      updateFormatOptions(formats) {
        const formatSelect = document.getElementById('formatSelect');
        formatSelect.innerHTML = '';
        formats.forEach((format) => {
          const option = document.createElement('option');
          option.value = format.format;
          option.textContent = format.format.toUpperCase();
          formatSelect.appendChild(option);
        });
        this.updateBitrateOptions(formats[0].format, formats);
        const currentFormat = formatSelect.value;
        this.toggleFormatSpecificOptions(currentFormat);
      }

      async getFormats() {
        try {
          const response = await fetch('/api/formats');
          const data = await response.json();
          return data.formats;
        } catch {
          return [];
        }
      }

      updateBitrateOptions(format, formats) {
        const bitrateSelect = document.getElementById('bitrateSelect');
        const formatData = formats.find((f) => f.format === format);
        if (!formatData) return;
        bitrateSelect.innerHTML = '';
        formatData.bitrates.forEach((bitrate) => {
          const option = document.createElement('option');
          option.value = bitrate;
          option.textContent = bitrate === 'lossless' ? t('quality.lossless') : bitrate;
          bitrateSelect.appendChild(option);
        });
      }

      initializeEventListeners() {
        document.getElementById('formatSelect').addEventListener('change', async (e) => {
            const format = e.target.value;
            this.toggleFormatSpecificOptions(format);
            const formats = await this.getFormats();
            this.updateBitrateOptions(format, formats);
          });
        document.getElementById('previewBtn').addEventListener('click', () => this.handlePreviewClick());
        document.getElementById('convertSelectedBtn').addEventListener('click', () => this.convertSelected());
        document.getElementById('convertAllBtn').addEventListener('click', () => this.convertAll());
        document.getElementById('selectAllChk').addEventListener('change', (e) => this.toggleSelectAll(e.target.checked));
        document.getElementById('playlistCheckbox').addEventListener('change', (e) => this.onPlaylistToggle(e.target.checked));
        document.getElementById('prevPageBtn').addEventListener('click', () => this.loadPage(this.currentPreview.page - 1));
        document.getElementById('nextPageBtn').addEventListener('click', () => this.loadPage(this.currentPreview.page + 1));
        document.getElementById('pageSizeSel').addEventListener('change', (e) => {
        this.currentPreview.pageSize = Number(e.target.value) || 50;
          if (this.currentPreview.url) this.loadPage(1, true);
        });
        document.getElementById('startIntegratedBtn').addEventListener('click', () => {
          this.startIntegratedSpotifyProcess();
        });

         document.getElementById('urlForm').addEventListener('submit', (e) => this.handleUrlSubmitWithSpinner(e));

        const startSpotifyBtn = document.getElementById('startSpotifyBtn');
        const convertMatchedBtn = document.getElementById('convertMatchedBtn');

        if (startSpotifyBtn) {
          startSpotifyBtn.addEventListener('click', () => this.startSpotifyPreview());
        }

        if (convertMatchedBtn) {
          convertMatchedBtn.addEventListener('click', () => this.convertMatchedSpotify());
        }

        document.getElementById('urlInput').addEventListener('input', (e) => {
          this.onUrlInputChange(e.target.value);
        });

        document.querySelectorAll('.lang-toggle [data-lang]').forEach(btn => {
          btn.addEventListener('click', async () => {
            await window.i18n?.setLang(btn.getAttribute('data-lang'));
          });
        });

        document.addEventListener('i18n:applied', () => {
        const modal = document.getElementById('settingsModal');
        if (modal) window.i18n?.apply?.(modal);
          if (this.currentPreview.url) this.renderPreview();
          for (const [id, job] of this.jobStates.entries()) {
            this.updateJobUI(job, this.jobToBatch.get(id) || null);
          }
        });
        document.getElementById('lyricsCheckbox').addEventListener('change', (e) => {
       this.includeLyrics = e.target.checked;
        });
        document.getElementById('sampleRateSelect').addEventListener('change', (e) => {
        this.currentSampleRate = parseInt(e.target.value);
      });
      }

      onUrlInputChange(url) {
        const isSpotify = isSpotifyUrl(url);

        if (isSpotify) {
          document.getElementById('playlistCheckboxContainer').style.display = 'none';
          document.getElementById('normalUrlActions').style.display = 'none';
          document.getElementById('urlSpotifyActions').style.display = 'flex';
          document.getElementById('spotifyPreviewCard').style.display = 'block';
        } else {
          document.getElementById('playlistCheckboxContainer').style.display = 'flex';
          document.getElementById('normalUrlActions').style.display = 'flex';
          document.getElementById('urlSpotifyActions').style.display = 'none';
          document.getElementById('spotifyPreviewCard').style.display = 'none';
        }
      }

      handlePreviewClick() {
        const url = document.getElementById('urlInput').value.trim();
        if (isSpotifyUrl(url)) {
          this.startSpotifyPreview();
        } else {
          this.previewPlaylist();
        }
      }

      onPlaylistToggle(isChecked) {
        if (isChecked) {
          const url = document.getElementById('urlInput').value.trim();
          if (!url) { this.hidePreview(); return; }
          this.previewPlaylist();
        } else {
          this.hidePreview();
        }
      }

      async startSpotifyPreview() {
        const url = document.getElementById('urlInput').value.trim();
        if (!url) {
          this.showNotification(t('notif.needUrl'), 'error', 'error');
          return;
        }

        try {
          const btn = document.getElementById('startSpotifyBtn');
          btn.classList.add('btn-loading');
          btn.disabled = true;

          const response = await fetch('/api/spotify/preview/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url })
          });

          if (!response.ok) {
            const error = await response.json().catch(()=>({}));
            const code  = error?.error?.code;
            const msg   = code ? t(`errors.${code}`) : (error?.error?.message || t('errors.startFailed'));
            throw new Error(msg);
          }

          const data = await response.json();
          this.currentSpotifyTask.id = data.mapId;

          document.getElementById('spotifyTitle').textContent = data.title || '-';
          document.getElementById('spotifyTotal').textContent = data.total || 0;
          document.getElementById('spotifyStatus').style.display = 'block';
          document.getElementById('spotifyStatusText').textContent = t('status.mappingStarted');

          this.streamSpotifyLogs(data.mapId);

        } catch (error) {
          this.showNotification(`${t('notif.errorPrefix')}: ${error.message}`, 'error', 'error');
        } finally {
          const btn = document.getElementById('startSpotifyBtn');
          btn.classList.remove('btn-loading');
          btn.disabled = false;
        }
      }

      showSpotifyPreview(data) {
        this.hidePreview();

        document.getElementById('spotifyPreviewCard').style.display = 'block';
        document.getElementById('spotifyTitle').textContent = data.title;
        document.getElementById('spotifyTotal').textContent = data.total;
        document.getElementById('spotifyMatched').textContent = '0';
        document.getElementById('spotifyProgress').textContent = '0%';
        document.getElementById('urlSpotifyActions').style.display = 'none';
        document.getElementById('spotifyStartActions').style.display = 'flex';
        document.getElementById('spotifyConvertActions').style.display = 'none';
        document.getElementById('spotifyDownloadSection').style.display = 'none';
        document.getElementById('spotifyLogs').innerHTML = '';
        document.getElementById('spotifyPreviewList').innerHTML = '';
        document.getElementById('spotifyDownloadList').innerHTML = '';
      }

      streamSpotifyLogs(mapId) {
        if (this.spotifyEventSource) {
          this.spotifyEventSource.close();
        }

        this.spotifyEventSource = new EventSource(`/api/spotify/preview/stream-logs/${mapId}`);
        const logsContainer = document.getElementById('spotifyLogs');
        const listContainer = document.getElementById('spotifyPreviewList');

        this.spotifyEventSource.onmessage = (event) => {
          const data = JSON.parse(event.data);

          switch (data.type) {
            case 'init':
              document.getElementById('spotifyTitle').textContent = data.title || '-';
              document.getElementById('spotifyTotal').textContent = data.total || 0;
              if (data.items && Array.isArray(data.items)) {
                data.items.forEach(item => this.addSpotifyItem(item));
              }
              break;

            case 'item':
              this.addSpotifyItem(data.item);
              if (data.logKey || data.log) {
                const msg = data.logKey ? t(data.logKey, data.logVars || {}) : this.normalizeLog(data.log);
                this.addLogEntry(msg, 'success');
                }
              break;

            case 'progress':
              this.updateSpotifyProgress(data.done, data.total);
              break;

            case 'log':
        {
          const msg = data.logKey
            ? t(data.logKey, data.logVars || {})
            : this.normalizeLog(data.message);
          this.addLogEntry(msg, data.level || 'info');
        }
        break;

            case 'done':
              {
          const msg = data.logKey
            ? t(data.logKey, data.logVars || {})
            : this.normalizeLog(data.log || t('status.completed'));
          this.addLogEntry(msg, data.status === 'completed' ? 'success' : 'error');

          if (data.status === 'completed') {
            this.addLogEntry(t('status.allMatchesCompleted'), 'success');
            this.onSpotifyMappingCompleted();
          }
          if (data.status === 'completed' || data.status === 'error') {
            this.spotifyEventSource.close();
          }
        }
        break;
          }
        };

        this.spotifyEventSource.onerror = (error) => {
          this.addLogEntry(t('errors.connectionError'), 'error');
          this.spotifyEventSource.close();
        };
      }

      addSpotifyItem(item) {
        const listContainer = document.getElementById('spotifyPreviewList');
        const matched = item.id !== null;

        const itemElement = document.createElement('div');
        itemElement.className = `spotify-track-item ${matched ? 'matched' : 'unmatched'}`;
        if (matched) {
          itemElement.dataset.ytId = item.id;
        }

        itemElement.innerHTML = `
          <div class="track-status">${matched ? '‚úÖ' : '‚ùå'}</div>
          <div class="track-info">
            <div class="track-title">${item.index}. ${this.escapeHtml(item.title)}</div>
            <div class="track-artist">${this.escapeHtml(item.uploader)}</div>
          </div>
          ${matched ? `<div class="progress-bar-mini"><div class="progress-fill-mini" style="width: 0%"></div></div>` : ''}
        `;

        listContainer.appendChild(itemElement);
        const matchedCount = listContainer.querySelectorAll('.matched').length;
        document.getElementById('spotifyMatched').textContent = matchedCount;
      }

      normalizeLog(msg) {
        if (msg == null) return '';
        if (typeof msg === 'string') {
          if (msg.startsWith('log.') || msg.startsWith('phase.') || msg.startsWith('status.')) {
            return t(msg);
          }
          return msg;
        }
        if (typeof msg === 'object') {
          if (msg.logKey) return t(msg.logKey, msg.logVars || {});
          if (msg.message) return this.normalizeLog(msg.message);
          if (msg.fallback) return msg.fallback;
          try { return JSON.stringify(msg); } catch { return String(msg); }
        }
        return String(msg);
      }

      addLogEntry(message, level = 'info') {
        const logsContainer = document.getElementById('spotifyLogs');
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${level}`;
        const timestamp = new Date().toLocaleTimeString();
        logEntry.textContent = `[${timestamp}] ${this.normalizeLog(message)}`;
        logsContainer.appendChild(logEntry);
        logsContainer.scrollTop = logsContainer.scrollHeight;
      }

      updateSpotifyProgress(done, total) {
        const progress = total > 0 ? Math.round((done / total) * 100) : 0;
        document.getElementById('spotifyProgress').textContent = `${progress}%`;
        document.querySelectorAll('.progress-fill-mini').forEach(bar => {
          bar.style.width = `${progress}%`;
        });
      }

      onSpotifyMappingCompleted() {
        this.currentSpotifyTask.completed = true;

        document.getElementById('spotifyStatusText').textContent = t('status.mappingCompleted');
        const convertMatchedBtn = document.getElementById('convertMatchedBtn');
        if (convertMatchedBtn) {
          convertMatchedBtn.style.display = 'inline-block';
        }
      }

    async startIntegratedSpotifyProcess() {
    const url = document.getElementById('urlInput').value.trim();
    const format = document.getElementById('formatSelect').value;
    const bitrate = document.getElementById('bitrateSelect').value;
    const sampleRate = document.getElementById('sampleRateSelect').value;
    const includeLyrics = document.getElementById('lyricsCheckbox').checked;

    if (!url) {
    this.showNotification(t('notif.needUrl'), 'error', 'error');
    return;
  }

  try {
    const btn = document.getElementById('startIntegratedBtn');
    btn.classList.add('btn-loading');
    btn.disabled = true;

    document.getElementById('spotifyPreviewCard').style.display = 'block';
    document.getElementById('spotifyTitle').textContent = t('status.starting');
    document.getElementById('spotifyTotal').textContent = '0';
    document.getElementById('spotifyMatched').textContent = '0';
    document.getElementById('spotifyProgress').textContent = '0%';
    document.getElementById('spotifyLogs').innerHTML = '';
    const listEl = document.getElementById('spotifyPreviewList');
    if (listEl) listEl.innerHTML = '';
    this.integratedRenderedCount = 0;

    const response = await fetch('/api/spotify/process/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        url,
        format,
        bitrate,
        sampleRate: sampleRate,
        includeLyrics
      })
    });

          if (!response.ok) {
            const error = await response.json().catch(()=>({}));
            const code  = error?.error?.code;
            const msg   = code ? t(`errors.${code}`) : (error?.error?.message || t('errors.startFailed'));
            throw new Error(msg);
          }
          const data = await response.json();
          document.getElementById('spotifyTitle').textContent = data.title || '-';
          document.getElementById('spotifyTotal').textContent = data.total || '0';
          this.trackJob(data.jobId);
          this.showNotification(t('notif.queue'), 'success', 'queue');
          this.streamIntegratedLogs(data.jobId);

        } catch (error) {
          this.showNotification(`${t('notif.errorPrefix')}: ${error.message}`, 'error', 'error');
          document.getElementById('spotifyLogs').innerHTML +=
            `<div class="log-entry error">[${new Date().toLocaleTimeString()}] ‚ùå ${t('notif.errorPrefix')}: ${this.escapeHtml(error.message)}</div>`;
        } finally {
          const btn = document.getElementById('startIntegratedBtn');
          btn.classList.remove('btn-loading');
          btn.disabled = false;
        }
      }

      streamIntegratedLogs(jobId) {
        const eventSource = new EventSource(`/api/stream/${jobId}`);
        const logsContainer = document.getElementById('spotifyLogs');

        eventSource.onmessage = (event) => {
          const job = JSON.parse(event.data);

          if (job.progress) {
            document.getElementById('spotifyProgress').textContent = `${job.progress}%`;
          }
          (() => {
            try {
              let line = '';
              if (job && job.__event && job.type === 'skip-hint') {
                if (job.lastLogKey) line = t(job.lastLogKey, job.lastLogVars || {});
                else if (job.raw)   line = this.normalizeBackendLog(job.raw);
                else if (job.message) line = this.normalizeBackendLog(job.message);
              } else if (typeof job.raw === 'string' && /SKIP_(HINT|SUMMARY):/i.test(job.raw)) {
                line = this.normalizeBackendLog(job.raw);
              }
              if (line) {
                this.addLogEntry(line, 'warning');
              }
            } catch (_) {}
          })();

         if (job.playlist) {
            document.getElementById('spotifyMatched').textContent = `${job.playlist.done || 0}/${job.playlist.total || 0}`;
          }

          if (job.phase || job.lastLog || job.lastLogKey) {
            const phaseText = {
              mapping: t('phase.mapping'),
              downloading: t('phase.downloading'),
              converting: t('phase.converting'),
              completed: t('phase.completed'),
              error: t('phase.error')
            };

            if (typeof job.lastLog === 'string') {
              job.lastLog = this.normalizeBackendLog(job.lastLog);
            }

            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${job.phase === 'error' ? 'error' : 'info'}`;

            const timestamp = new Date().toLocaleTimeString();

            if (job.lastLogKey) {
              logEntry.textContent = `[${timestamp}] ${t(job.lastLogKey, job.lastLogVars || {})}`;
            } else if (job.lastLog) {
              const txt = (typeof job.lastLog === 'string' && (job.lastLog.startsWith('log.') || job.lastLog.startsWith('phase.') || job.lastLog.startsWith('status.')))
                ? t(job.lastLog, job.lastLogVars || {})
                : job.lastLog;
              logEntry.textContent = `[${timestamp}] ${txt}`;
            } else if (job.phase) {
              logEntry.textContent = `[${timestamp}] ${phaseText[job.phase] || job.phase}`;
            }

            logsContainer.appendChild(logEntry);
            logsContainer.scrollTop = logsContainer.scrollHeight;
          }

          if (job?.metadata?.frozenEntries && Array.isArray(job.metadata.frozenEntries)) {
            const arr = job.metadata.frozenEntries;
            for (let i = this.integratedRenderedCount; i < arr.length; i++) {
              this.addSpotifyItem(arr[i]);
            }
            this.integratedRenderedCount = arr.length;
            const matchedCount = document.getElementById('spotifyPreviewList')
              .querySelectorAll('.matched').length;
            document.getElementById('spotifyMatched').textContent = matchedCount;
          }
        };

        eventSource.onerror = (error) => {
          console.error('Entegre log SSE error:', error);
          const logEntry = document.createElement('div');
          logEntry.className = 'log-entry error';
          logEntry.textContent = `[${new Date().toLocaleTimeString()}] ‚ùå ${t('errors.streamDisconnected')}`;
          logsContainer.appendChild(logEntry);
          logsContainer.scrollTop = logsContainer.scrollHeight;
          eventSource.close();
        };
      }

      updateSpotifyPreviewList(entries) {
        const listContainer = document.getElementById('spotifyPreviewList');
        listContainer.innerHTML = '';

        entries.forEach((item, index) => {
          const matched = item.id !== null;

          const itemElement = document.createElement('div');
          itemElement.className = `spotify-track-item ${matched ? 'matched' : 'unmatched'}`;
          if (matched) {
            itemElement.dataset.ytId = item.id;
          }

          itemElement.innerHTML = `
            <div class="track-status">${matched ? '‚úÖ' : '‚ùå'}</div>
            <div class="track-info">
              <div class="track-title">${item.index}. ${this.escapeHtml(item.title)}</div>
              <div class="track-artist">${this.escapeHtml(item.uploader)}</div>
            </div>
            ${matched ? `<div class="progress-bar-mini"><div class="progress-fill-mini" style="width: 0%"></div></div>` : ''}
          `;

          listContainer.appendChild(itemElement);
        });

        const matchedCount = listContainer.querySelectorAll('.matched').length;
        document.getElementById('spotifyMatched').textContent = matchedCount;
      }
      async convertMatchedSpotify() {
        if (!this.currentSpotifyTask.id) {
          this.showNotification(t('notif.spotifyMappingFirst'), 'error', 'error');
          return;
        }

        try {
          const format = document.getElementById('formatSelect').value;
          const bitrate = document.getElementById('bitrateSelect').value;
          const sampleRate = document.getElementById('sampleRateSelect').value;
          const includeLyrics = document.getElementById('lyricsCheckbox').checked;
          const validItems = this.getCurrentSpotifyMatchedItems();
          if (validItems.length === 0) {
            this.showNotification(t('notif.noMatchedTracks'), 'error', 'error');
            return;
          }

          const payload = {
            url: document.getElementById('urlInput').value.trim(),
            format,
            bitrate,
            sampleRate: sampleRate,
            isPlaylist: true,
            selectedIndices: validItems.map(item => item.index),
            spotifyMapId: this.currentSpotifyTask.id,
            metadata: {
              source: "spotify",
              spotifyTitle: document.getElementById('spotifyTitle').textContent,
              selectedIds: validItems.map(item => item.id),
              frozenEntries: validItems,
              spotifyMapId: this.currentSpotifyTask.id,
              includeLyrics
            }
          };

          document.getElementById('spotifyStatusText').textContent = t('status.conversionStarting');

          const jobId = await this.submitSpotifyJob(payload);

          if (jobId) {
            this.currentSpotifyTask.jobId = jobId;
            document.getElementById('spotifyStatusText').textContent = t('status.conversionStarted');
            this.showNotification(t('notif.tracksQueued', { count: validItems.length }), 'success', 'queue');
            this.trackJob(jobId);
          }

        } catch (error) {
          this.showNotification(`${t('notif.conversionError')}: ${error.message}`, 'error', 'error');
          document.getElementById('spotifyStatusText').textContent = t('status.conversionFailed');
        }
      }

      getCurrentSpotifyMatchedItems() {
        const validItems = [];
        const listItems = document.querySelectorAll('.spotify-track-item.matched');

        listItems.forEach(item => {
          const titleEl = item.querySelector('.track-title');
          const artistEl = item.querySelector('.track-artist');
          if (titleEl && artistEl) {
            const title = titleEl.textContent.replace(/^\d+\.\s/, '');
            const artist = artistEl.textContent;
            const index = parseInt(titleEl.textContent.match(/^(\d+)\./)?.[1]) || validItems.length + 1;
            const ytId = item.dataset.ytId || `spotify_${index}_${Date.now()}`;

            validItems.push({
              title,
              uploader: artist,
              index: index,
              id: ytId
            });
          }
        });

        return validItems;
      }

      async getValidSpotifyItems() {
        const validItems = [];
        const listItems = document.querySelectorAll('.spotify-track-item.matched');

        listItems.forEach(item => {
          const titleEl = item.querySelector('.track-title');
          const artistEl = item.querySelector('.track-artist');
          if (titleEl && artistEl) {
            const title = titleEl.textContent.replace(/^\d+\.\s/, '');
            const artist = artistEl.textContent;
            const index = parseInt(titleEl.textContent.match(/^(\d+)\./)?.[1]) || validItems.length + 1;
            const tempId = `spotify_${index}_${Date.now()}`;

            validItems.push({
              title,
              uploader: artist,
              index: index,
              id: tempId
            });
          }
        });

        return validItems;
      }

      async submitSpotifyJob(payload) {
        try {
          const response = await fetch('/api/jobs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const e = await response.json().catch(()=>({}));
            throw new Error(e?.error?.message || t('errors.jobCreationFailed'));
          }

          const result = await response.json();
          return result.id;

        } catch (error) {
          console.error('Spotify job submission error:', error);
          throw error;
        }
      }

      trackSpotifyJob(jobId) {
        const eventSource = new EventSource(`/api/stream/${jobId}`);

        eventSource.onmessage = (event) => {
          const job = JSON.parse(event.data);
          job.status = this.normalizeStatus(job.status);
          job.currentPhase = this.normalizeStatus(job.currentPhase);
          job.phase = this.normalizeStatus(job.phase);
          this.updateSpotifyJobUI(job);


          if (job.status === 'completed' || job.status === 'error' || job.status === 'canceled') {
            eventSource.close();
            this.onSpotifyJobCompleted(job);
          }
        };

        eventSource.onerror = (error) => {
          console.error('Spotify job SSE error:', error);
          eventSource.close();
        };
      }

      updateSpotifyJobUI(job) {
        let statusText = `${t('status.' + job.status) || job.status} - ${job.progress}%`;

        if (job.playlist) {
          statusText += ` (${job.playlist.done}/${job.playlist.total})`;
        }

        document.getElementById('convertStatusText').textContent = statusText;
      }

      onSpotifyJobCompleted(job) {
        if (job.status === 'completed') {
          document.getElementById('convertStatusText').textContent = t('status.completed');
          if (job.resultPath || job.zipPath) {
            this.showSpotifyDownloads(job);
          }
        } else {
          document.getElementById('convertStatusText').textContent = t('status.error');
          document.getElementById('convertMatchedBtn').disabled = false;
        }
      }

      showSpotifyDownloads(job) {
        const downloadList = document.getElementById('spotifyDownloadList');
        downloadList.innerHTML = '';
        const hasLyrics = !!job?.metadata?.includeLyrics;
        if (Array.isArray(job.resultPath)) {
          job.resultPath.forEach((result, index) => {
            const item = document.createElement('div');
            item.className = 'download-item';
            const trackTitle = job.metadata?.frozenEntries?.[index]?.title || t('ui.track', { number: index + 1 });
            item.innerHTML = `
              <span>${index + 1}. ${this.escapeHtml(trackTitle)}</span>
              <a href="${this.toRelative(result.outputPath)}" class="download-btn" download>
                ${t('download.single')}
              </a>
            `;
            downloadList.appendChild(item);
          });
        }

        if (job.zipPath) {
          const zipItem = document.createElement('div');
          zipItem.className = 'download-item zip-all';
          zipItem.innerHTML = `
            <strong>${t('ui.all')}:</strong>
          <a href="${this.toRelative(job.zipPath)}" class="download-btn" download>
            ${hasLyrics ? t('download.allWithLyrics') : t('download.all')}
          </a>
          `;
          downloadList.appendChild(zipItem);
        }
        document.getElementById('spotifyDownloadSection').style.display = 'block';
      }

      async handleUrlSubmit(e) {
      e.preventDefault();
      const url = document.getElementById('urlInput').value.trim();
      const format = document.getElementById('formatSelect').value;
      const bitrate = document.getElementById('bitrateSelect').value;
      const sampleRate = document.getElementById('sampleRateSelect').value;
      const isPlaylist = document.getElementById('playlistCheckbox').checked;
      const sequential = document.getElementById('sequentialChk')?.checked;
      const includeLyrics = document.getElementById('lyricsCheckbox').checked;

    if (isSpotifyUrl(url)) {
    if (!this.currentSpotifyTask.completed) {
      this.showNotification(t('notif.completeSpotifyFirst'), 'error', 'error');
      return;
    }
    await this.convertMatchedSpotify();
    return;
  }

  if (isPlaylist) {
    const selectedIndices = Array.from(this.currentPreview.selected);
    if (sequential && selectedIndices.length > 1) {
      const batchId = `b${Date.now().toString(36)}${Math.random().toString(36).slice(2,7)}`;
      this.ensureBatch(batchId, selectedIndices.length, { format, bitrate, source: t('ui.youtubePlaylist') });
      for (const idx of selectedIndices) {
        const payload = {
          url, format, bitrate,
          sampleRate: sampleRate,
          isPlaylist: true,
          selectedIndices: [idx],
          clientBatch: batchId,
          includeLyrics
        };
        this.submitJob(payload);
      }
    } else {
      const payload = {
        url, format, bitrate,
        isPlaylist: true,
        sampleRate: sampleRate,
        selectedIndices: selectedIndices.length ? selectedIndices : 'all',
        includeLyrics
      };
      await this.submitJob(payload);
    }
  } else {
    const payload = {
      url, format, bitrate,
      isPlaylist: false,
      sampleRate: Number(sampleRate),
      includeLyrics
    };
    await this.submitJob(payload);
  }

  document.getElementById('urlForm').reset();
  document.getElementById('playlistCheckbox').checked = false;
  document.getElementById('lyricsCheckbox').checked = false;
  this.hidePreview();
}

  async handleFileSubmit(e) {
  e.preventDefault();
  const fileInput = document.getElementById('fileInput');
  const format = document.getElementById('formatSelect').value;
  const bitrate = document.getElementById('bitrateSelect').value;
  const sampleRate = document.getElementById('sampleRateSelect').value;
  const includeLyrics = document.getElementById('lyricsCheckbox').checked;

  if (!fileInput.files.length) {
    this.showNotification(t('notif.pickFile'), 'error', 'error');
    return;
  }

  const formData = new FormData();
  formData.append('file', fileInput.files[0]);
  formData.append('format', format);
  formData.append('bitrate', bitrate);
  formData.append('sampleRate', sampleRate);
  formData.append('includeLyrics', includeLyrics);

  await this.submitJob(formData, true);
  document.getElementById('fileForm').reset();
  document.getElementById('lyricsCheckbox').checked = false;
}

      async submitJob(payload, isFormData = false) {
      try {
        console.log("G√∂nderilen payload:", payload);

        const response = await fetch('/api/jobs', {
          method: 'POST',
          headers: isFormData ? {} : { 'Content-Type': 'application/json' },
          body: isFormData ? payload : JSON.stringify(payload)
        });

        if (!response.ok) {
          const e = await response.json().catch(()=>({}));
          const msg = e?.error?.code ? t(`errors.${e.error.code}`) : (e?.error?.message || 'error');
          throw new Error(msg);
        }

        const result = await response.json();
        console.log("Job olu≈üturuldu:", result);

          if (result.clientBatch) {
            this.jobToBatch.set(result.id, result.clientBatch);
            this.ensureBatch(result.clientBatch, result.batchTotal, {
              format: result.format,
              bitrate: result.bitrate,
              source: result.source
            });
            this.trackJob(result.id, result.clientBatch);
          } else {
            const empty = document.getElementById('job-empty');
            if (empty) empty.remove();
            this.trackJob(result.id);
          }

          this.showNotification(t('notif.queue'), 'success', 'queue');
        } catch (error) {
          console.error("Job g√∂nderme hatasƒ±:", error);
          this.showNotification(`${t('notif.errorPrefix')}: ${error.message}`, 'error', 'error');
        }
      }

      trackJob(jobId, batchId = null) {
        if (this.currentJobs.has(jobId)) return;
        const eventSource = new EventSource(`/api/stream/${jobId}`);
        let firstUpdate = true;
        eventSource.onmessage = (event) => {
          const job = JSON.parse(event.data);
          job.status = this.normalizeStatus(job.status);
          job.currentPhase = this.normalizeStatus(job.currentPhase);
          job.phase = this.normalizeStatus(job.phase);
          this.jobStates.set(jobId, job);
          if (firstUpdate) {
                firstUpdate = false;
                document.dispatchEvent(new CustomEvent('job:first-update', { detail: { jobId, job } }));
            }
          this.updateJobUI(job, batchId);
          if (job.status === 'completed' || job.status === 'error' || job.status === 'canceled') {
            eventSource.close();
            this.currentJobs.delete(jobId);
          }
        };
        eventSource.onerror = (error) => {
          console.error('SSE error:', error);
          eventSource.close();
          this.currentJobs.delete(jobId);
        };
        this.currentJobs.set(jobId, eventSource);
      }

      uiCurrentIndex(job) {
      const total = job.playlist?.total;
      const done  = job.playlist?.done;
      const current = job.playlist?.current || done;
      if (Number.isFinite(total) && Number.isFinite(done) && total > 0) {
        return Math.min(Math.max(0, done || 0), Math.max(0, total - 1));
      }
      return null;
    }

    uiNowTitle(job) {
      if (job.metadata?.isPlaylist && Array.isArray(job.metadata?.frozenEntries) && job.metadata.frozenEntries.length) {
        const i0 = job.playlist?.current || this.uiCurrentIndex(job);
        if (i0 !== null && job.metadata.frozenEntries[i0]) {
          const e = job.metadata.frozenEntries[i0];
          return `${e.index}. ${e.title}`;
        }
      }
      const ex = job.metadata?.extracted || {};
      return ex.track || ex.title || job.metadata?.originalName || null;
    }

      updateJobUI(job, batchId = null) {
        const statusNorm = this.normalizeStatus(job.status);
        const batchKey = batchId || job.clientBatch;

        if (batchKey) {
          const batch = this.batches.get(batchKey);
          if (batch) {
            batch.jobs.add(job.id);
            this.jobStates.set(job.id, job);

            if (statusNorm === 'completed' && job.resultPath && !Array.isArray(job.resultPath)) {
              const selIdx = Array.isArray(job.metadata?.selectedIndices)
                ? job.metadata.selectedIndices[0]
                : null;

              let resolvedTitle =
                job.metadata?.extracted?.track ||
                job.metadata?.originalName ||
                (selIdx && this.currentPreview.indexToTitle.get(selIdx)) ||
                t('ui.track');

              this.appendBatchRow(batchKey, {
                title: resolvedTitle,
                href: this.toRelative(job.resultPath)
              });
            }
            this.updateBatchProgress(batchKey);
              const allJobs = Array.from(batch.jobs);
              const completedJobs = allJobs.filter(jobId => {
              const j = this.jobStates.get(jobId);
              return j && this.normalizeStatus(j.status) === 'completed';
            }).length;
            if (completedJobs >= batch.total && !batch.el.querySelector('.zip-all')) {
              const lastCompletedJob = allJobs.map(id => this.jobStates.get(id))
              .find(j => j && this.normalizeStatus(j.status) === 'completed' && j.zipPath);

              if (lastCompletedJob && lastCompletedJob.zipPath) {
                const zipBtn = document.createElement('div');
                zipBtn.className = 'download-item zip-all';
                zipBtn.innerHTML = `
                  <strong>${t('ui.all')}:</strong>
                  <a href="${this.toRelative(lastCompletedJob.zipPath)}" class="download-btn" download>${t('download.allZip')}</a>
                `;
                batch.el.querySelector('.download-list').appendChild(zipBtn);
              }
            }
          }
          return;
        }

      let phaseInfo = '';
      if (job.metadata?.source === 'spotify' && job.phase) {
        const phaseText = {
        mapping: t('phase.mapping'),
        downloading: t('phase.downloading'),
        converting: t('phase.converting'),
        completed: t('phase.completed')
      };
      phaseInfo = ` ‚Ä¢ ${phaseText[job.phase] || job.phase}`;
    }

    let phaseDetails = '';
    if (job.currentPhase) {
    const phaseTexts = {
    preparing: t('phase.preparing'),
    downloading: t('phase.downloading'),
    converting: t('phase.converting'),
    completed: t('phase.completed'),
    canceled: t('status.canceled'),
    cancelled: t('status.canceled'),
    error: t('phase.error')
  };

  const currentPhaseText = phaseTexts[job.currentPhase] || job.currentPhase;

  if (job.playlist && job.playlist.total) {
    if (job.metadata?.source === 'spotify') {
      let downloaded, converted;
      if (job.currentPhase === 'downloading') {
        downloaded = job.playlist.done || 0;
        converted = 0;
      } else if (job.currentPhase === 'converting') {
        downloaded = job.playlist.total;
        converted = job.playlist.done || 0;
      } else {
        downloaded = job.playlist.done || 0;
        converted = job.playlist.done || 0;
      }

      phaseDetails = `
        <div class="phase-details">
          <div class="phase-details__title">${currentPhaseText}</div>
          <div class="phase-details__grid">
            <span class="phase-details__item">
              üéµ ${t('ui.current')}:
              <span class="phase-details__value">${(job.playlist.current || job.playlist.done || 0) + 1}</span>
            </span>
            <span class="phase-details__item">
              üì• ${t('ui.downloading')}:
              <span class="phase-details__value">${downloaded}/${job.playlist.total}</span>
            </span>
            <span class="phase-details__item">
              ‚ö° ${t('ui.converting')}:
              <span class="phase-details__value">${converted}/${job.playlist.total}</span>
            </span>
          </div>
        </div>
      `;
    }
    else {
      let downloaded, converted;

      if (job.counters && typeof job.counters.dlDone === 'number' && typeof job.counters.cvDone === 'number') {
        downloaded = job.counters.dlDone;
        converted = job.counters.cvDone;
      } else {
        downloaded = job.downloadProgress >= 100 ? job.playlist.total : Math.floor((job.downloadProgress / 100) * job.playlist.total);
        converted = job.convertProgress >= 100 ? job.playlist.total : Math.floor((job.convertProgress / 100) * job.playlist.total);
      }
      const currentTrack = job.playlist.current !== undefined ? job.playlist.current + 1 : (downloaded + 1);

      phaseDetails = `
        <div class="phase-details">
          <div class="phase-details__title">${currentPhaseText}</div>
          <div class="phase-details__grid">
            <span class="phase-details__item">
              üéµ ${t('ui.current')}:
              <span class="phase-details__value">${currentTrack}</span>
            </span>
            <span class="phase-details__item">
              üì• ${t('ui.downloading')}:
              <span class="phase-details__value">${downloaded}/${job.playlist.total}</span>
            </span>
            <span class="phase-details__item">
              ‚ö° ${t('ui.converting')}:
              <span class="phase-details__value">${converted}/${job.playlist.total}</span>
            </span>
          </div>
        </div>
      `;
    }
  } else {
    phaseDetails = `
      <div class="phase-details" style="margin-top: 8px;">
        <div class="phase-details__title" style="margin-bottom: 6px;">${currentPhaseText}</div>
        <div class="phase-details__grid">
          <span class="phase-details__item">
            üì• ${t('ui.downloading')}:
            <span class="phase-details__value">${Math.floor(job.downloadProgress || 0)}%</span>
          </span>
          <span class="phase-details__item">
            ‚ö° ${t('ui.converting')}:
            <span class="phase-details__value">${Math.floor(job.convertProgress || 0)}%</span>
          </span>
        </div>
      </div>
    `;
  }
    }

    let jobElement = document.getElementById(`job-${job.id}`);

    if (!jobElement) {
      const empty = document.getElementById('job-empty');
      if (empty) empty.remove();
      jobElement = document.createElement('div');
      jobElement.id = `job-${job.id}`;
      jobElement.className = 'job-item';
      document.getElementById('jobList').appendChild(jobElement);
    }

    const statusText = {
      queued: t('status.queued'),
      running: t('status.running'),
      completed: t('status.completed'),
      error: t('status.error'),
      canceled: t('status.canceled'),
      cancelled: t('status.canceled')
    };

    let jobTitle = job.metadata?.originalName || job.metadata?.source || '';

    if (job.metadata?.source === 'spotify') {
      jobTitle = `üéµ ${job.metadata.spotifyTitle || t('ui.spotifyPlaylist')}`;
    }
    {
      const nowTrack = this.uiNowTitle(job);
      if (job.metadata?.isPlaylist && nowTrack) {
        const listName =
          job.metadata?.frozenTitle
          || (job.metadata?.source === 'spotify'
                ? (job.metadata?.spotifyTitle || t('ui.spotifyPlaylist'))
                : t('ui.youtubePlaylist'));
        jobTitle = `${this.escapeHtml(listName)} ‚Äî ${this.escapeHtml(nowTrack)}`;
      }
    }

    const skippedCount = this.computeSkipped(job);
    const skippedKeywords = /(private|izin|skipp?ed|unavailable|atlan(?:d|an)|blocked|copyright|region|geo)/i;
    const showSkippedBadge =
    (skippedCount > 0) ||
    (job.lastLog && skippedKeywords.test(String(job.lastLog))) ||
    (job.lastLogKey && skippedKeywords.test(String(job.lastLogKey))) ||
    (job.error && skippedKeywords.test(String(job.error?.message || job.error)));

  const skippedBadge = showSkippedBadge
    ? `<span class="chip chip--warn" title="${this.escapeHtml(job.lastLog || 'atlananlar')}">‚ö†Ô∏è ${t('jobs.skipped')}${skippedCount ? ` (${skippedCount})` : ''}</span>`
    : '';

    let resultContent = '';

    if (job.status === 'completed') {
      if (Array.isArray(job.resultPath)) {
        const successfulResults = job.resultPath.filter(r => r.outputPath && !r.error);
        if (successfulResults.length > 0) {
        const hasLyrics = job.metadata.includeLyrics;
          const downloadText = hasLyrics ? t('download.withLyrics') : t('download.single');
          resultContent = `
            <div class="download-list">
              ${successfulResults.map((r, i) => {
                const trackTitle = job.metadata?.frozenEntries?.[i]?.title || t('ui.track', { number: i + 1 });
                const lrcBtn = r.lyricsPath
              ? `<a href="${this.toRelative(r.lyricsPath)}" class="download-btn" download>${t('download.lyrics')}</a>`
              : '';
              return `
                  <div class="download-item">
                    <span>${i + 1}. ${this.escapeHtml(trackTitle)}</span>
                    <a href="${this.toRelative(r.outputPath)}" class="download-btn" download>${t('download.single')}</a>
                    ${lrcBtn}
                    </div>
                `;
              }).join('')}
              ${job.zipPath ? `
                <div class="download-item" style="margin-top:8px;">
                  <strong>${t('ui.all')}:</strong>
                  <a href="${this.toRelative(job.zipPath)}" class="download-btn" download>
                     ${hasLyrics ? t('download.allWithLyrics') : t('download.all')}
                   </a>
                </div>` : ''}
            </div>
          `;
        } else {
          resultContent = `<div style="color: var(--error); font-size: 13px;">‚ùå ${t('ui.noFilesConverted')}</div>`;
        }
      } else if (job.resultPath) {
            const rp = (typeof job.resultPath === 'string')
               ? { outputPath: job.resultPath }
               : job.resultPath;
                const hasLyricsFlag = !!rp.lyricsPath;
                const baseBtn = `<a href="${this.toRelative(rp.outputPath)}" class="download-btn" download>${t('download.single')}</a>`;
                const lrcBtn  = hasLyricsFlag
                ? `<a href="${this.toRelative(rp.lyricsPath)}" class="download-btn" download>${t('download.lyrics')}</a>`
                  : '';
                resultContent = `${baseBtn} ${lrcBtn}`;
              }
            }

    const totalProgress = job.progress || 0;

    let lyricsInfo = '';

    if (job.metadata?.includeLyrics && job.metadata?.lyricsStats) {
      const stats = job.metadata.lyricsStats;
      lyricsInfo = `<div class="lyrics-stats" style="font-size: 12px; color: var(--text-muted); margin: 4px 0;">
        üéº ${t('label.includeLyrics2')}: ${t('ui.found')} ${stats.found}, ${t('ui.notFound')} ${stats.notFound}
      </div>`;
    }

  let lastLogInfo = '';

  if (job.lastLog || job.lastLogKey) {
    const raw = job.lastLogKey ? t(job.lastLogKey, job.lastLogVars || {}) : this.normalizeLog(job.lastLog);
    lastLogInfo = `<div class="last-log" style="font-size: 12px; color: var(--text-muted); margin: 4px 0; font-style: italic;">
      ${this.escapeHtml(raw)}
    </div>`;
  }

  jobElement.innerHTML = `
    <strong>${this.escapeHtml(jobTitle)}</strong>
    <div style="font-size: 13px; color: var(--text-muted); margin: 8px 0;">
  ${job.format.toUpperCase()} ‚Ä¢ ${job.bitrate}
  ${job.sampleRate ? ` ‚Ä¢ ${Math.round(job.sampleRate / 1000)} kHz` : ''}
  ${job.metadata?.isPlaylist ? ` ‚Ä¢ ${t('ui.playlist')}` : ''}
  ${job.metadata?.includeLyrics ? ` ‚Ä¢ üéº ${t('label.includeLyrics2')}` : ''}
  ${phaseInfo}
  ${skippedBadge}
</div>

    ${lyricsInfo}
    ${lastLogInfo}

    ${phaseDetails}

      ${(() => {
        const nt = this.uiNowTitle(job);
        return nt ? `<div class="muted" style="font-size:12px; margin: 8px 0 4px 0;">‚ñ∂Ô∏è <strong>${this.escapeHtml(nt)}</strong></div>` : '';
      })()}

      <div class="progress-bar">
        <div class="progress-fill" style="width: ${totalProgress}%"></div>
      </div>
      <div class="job-actions" style="display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; margin-top: 8px;">
        <span class="status status-${job.status}">${statusText[job.status]}</span>
        <div style="display:flex; gap:8px; align-items:center;">
          ${resultContent}
          <button class="btn-danger" data-stop="${job.id}" ${(['completed','error','canceled'].includes(statusNorm)) ? 'disabled' : ''} title="${t('btn.stop')}">${t('btn.stop')}</button>
        </div>
      </div>
      ${job.error ? `<div style="color: var(--error); font-size: 13px; margin-top: 8px; padding: 8px; background: var(--bg-card); border-radius: 6px;">${this.escapeHtml(job.error)}</div>` : ''}
    `;
    const stopBtn = jobElement.querySelector(`[data-stop="${job.id}"]`);
    if (stopBtn) {
      stopBtn.addEventListener('click', async () => {
      stopBtn.disabled = true;

    const bId = this.jobToBatch.get(job.id) || job.clientBatch || null;

    try {
      if (bId) {
        await this.cancelBatch(bId);
        } else {
          const r = await fetch(`/api/jobs/${encodeURIComponent(job.id)}/cancel`, { method: 'POST' });
          if (!r.ok) {
            const e = await r.json().catch(()=>({}));
            throw new Error(e?.error?.message || t('notif.cancelFailed'));
          }
          const js = this.jobStates.get(job.id) || {};
          js.status = 'canceled';
          js.phase = 'canceled';
          this.jobStates.set(job.id, js);
          this.updateJobUI(js, this.jobToBatch.get(job.id) || null);
        }

        this.showNotification(t('notif.canceledByUser'), 'success', 'action');
      } catch (e) {
        stopBtn.disabled = false;
        this.showNotification(`${t('notif.cancelFailed')}: ${e.message}`, 'error', 'error');
      }
    });
  }
  }
      ensureBatch(batchId, total, meta) {
        let batch = this.batches.get(batchId);

        if (batch) {
          if (Number.isFinite(total)) batch.total = total;
          return batch;
        }

        const jobList = document.getElementById('jobList');
        const empty = document.getElementById('job-empty');
        if (empty) empty.remove();

        const batchElement = document.createElement('div');
        batchElement.className = 'job-item';
        batchElement.id = `batch-${batchId}`;
        const sourceText = meta?.source || t('ui.playlist');
        const seqText = t('label.sequential');
        batchElement.innerHTML = `
          <strong>${sourceText} ‚Äî ${t('label.sequential')}</strong>
          <div style="font-size: 13px; color: var(--text-muted); margin: 8px 0;">
            ${meta?.format?.toUpperCase() || ''} ‚Ä¢ ${meta?.bitrate || ''}
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="batch-progress-${batchId}" style="width: 0%"></div>
          </div>
          <div class="batch-info">
            ${t('batch.done')}: <span id="batch-done-${batchId}">0</span> / <span id="batch-total-${batchId}">${total || '?'}</span>
          </div>
          <div class="batch-actions" style="margin:8px 0 4px; display:flex; justify-content:flex-end;">
            <button class="btn-danger" data-stop-batch="${batchId}">
              ${t('btn.stop') || 'Hepsini Durdur'}
            </button>
          </div>
          <div class="download-list" id="batch-list-${batchId}"></div>
        `;

        jobList.appendChild(batchElement);

        batch = {
          el: batchElement,
          total: total || 0,
          done: 0,
          jobs: new Set()
        };

        this.batches.set(batchId, batch);
        const stopBtn = batchElement.querySelector(`[data-stop-batch="${batchId}"]`);
        if (stopBtn) {
          stopBtn.addEventListener('click', () => this.cancelBatch(batchId));
        }
        return batch;
      }

      appendBatchRow(batchId, { title, href }) {
        const list = document.getElementById(`batch-list-${batchId}`);
        if (!list) return;

        const row = document.createElement('div');
        row.className = 'download-item';
        row.innerHTML = `
          <span>${this.escapeHtml(title || t('ui.track'))}</span>
          <a href="${this.toRelative(href)}" class="download-btn" download>${t('download.single')}</a>
        `;
        list.appendChild(row);
      }

      updateBatchProgress(batchId) {
        const batch = this.batches.get(batchId);
        if (!batch) return;
        const completedJobs = Array.from(batch.jobs).filter(jobId => {
          const job = this.jobStates.get(jobId);
          return job && job.status === 'completed';
        }).length;

        batch.done = completedJobs;

        const progressElement = document.getElementById(`batch-progress-${batchId}`);
        const doneElement = document.getElementById(`batch-done-${batchId}`);
        const totalElement = document.getElementById(`batch-total-${batchId}`);

        if (progressElement && doneElement && totalElement) {
          const percentage = batch.total > 0 ? Math.min(100, (completedJobs / batch.total) * 100) : 0;
          progressElement.style.width = `${percentage}%`;
          doneElement.textContent = completedJobs;
          totalElement.textContent = batch.total;
        }

        const anyActive = Array.from(batch.jobs).some(jobId => {
        const j = this.jobStates.get(jobId);
        const s = j ? this.normalizeStatus(j.status) : 'completed';
        return !['completed','error','canceled'].includes(s);
        });
        const stopBtn = document.querySelector(`[data-stop-batch="${batchId}"]`);
        if (stopBtn) stopBtn.disabled = !anyActive;
        }

      async previewPlaylist() {
        const url = document.getElementById('urlInput').value.trim();
        const isPlaylist = document.getElementById('playlistCheckbox').checked;
        const btn = document.getElementById('previewBtn');
        if (!url) {
          this.showNotification(t('notif.needUrl'), 'error', 'error');
          return;
        }
        if (isSpotifyUrl(url)) {
          try {
            btn?.classList.add('btn-loading');
            btn?.setAttribute('disabled','disabled');
            btn.textContent = t('ui.loading');
            const batchSize = Number(document.getElementById('pageSizeSel').value) || 10;
            await this.streamPreviewByPaging(url, Math.max(1, Math.min(50, batchSize)));
          } catch (e) {
            this.showNotification(`${t('notif.errorPrefix')}: ${e.message}`, 'error', 'error');
          } finally {
            btn?.classList.remove('btn-loading');
            btn?.removeAttribute('disabled');
            btn.textContent = t('btn.preview');
          }
          return;
        }
        if (!isPlaylist) {
          this.showNotification(t('notif.checkPlaylist'), 'error', 'error');
          return;
        }
        this.currentPreview.url = url;
        this.currentPreview.page = 1;
        this.currentPreview.pageSize = Number(document.getElementById('pageSizeSel').value) || 25;
        try {
          btn?.classList.add('btn-loading');
          btn?.setAttribute('disabled','disabled');
          btn.textContent = t('ui.loading');
          if (this.previewAbort) this.previewAbort.abort();
          this.previewAbort = new AbortController();
          const res = await fetch('/api/playlist/preview', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              url,
              page: this.currentPreview.page,
              pageSize: this.currentPreview.pageSize
            }),
            signal: this.previewAbort.signal
          });
          const data = await res.json();
          if (!res.ok) {
            const code = data?.error?.code || 'PREVIEW_FAILED';
            throw new Error(t(`errors.${code}`) || t('errors.previewFailed'));
          }

          this.currentPreview.items = data.items || [];
          this.currentPreview.title = data.playlist?.title || '';
          this.currentPreview.count = data.playlist?.count || 0;
          document.getElementById('pageNo').textContent = String(this.currentPreview.page);
          document.getElementById('pageSizeSel').value = String(this.currentPreview.pageSize);
          this.renderPreview();
          this.showPreview();
        } catch (e) {
          this.showNotification(`${t('notif.errorPrefix')}: ${e.message}`, 'error', 'error');
        } finally {
          btn?.classList.remove('btn-loading');
          btn?.removeAttribute('disabled');
          btn.textContent = t('btn.preview');
        }
      }

      async streamPreviewByPaging(url, batchSize){
        this.currentPreview.url = url;
        this.currentPreview.isSpotify = true;
        this.currentPreview.streaming = true;
        this.currentPreview.selected = new Set();
        this.currentPreview.items = [];
        this.currentPreview.page = 1;
        this.currentPreview.pageSize = batchSize;
        this.showPreview();

        const listEl = document.getElementById('previewList');
        const pagerPrev = document.getElementById('prevPageBtn');
        const pagerNext = document.getElementById('nextPageBtn');
        pagerPrev.disabled = true; pagerNext.disabled = true;

        const first = await fetch('/api/playlist/preview', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ url, page: 1, pageSize: batchSize })
        });
        const firstData = await first.json();
        if (!first.ok) throw new Error(firstData?.error?.message || t('errors.previewFailed'));
        this.currentPreview.title = firstData?.playlist?.title || '-';
        this.currentPreview.count = Number(firstData?.playlist?.count || 0);
        document.getElementById('plTitle').textContent = this.currentPreview.title;
        document.getElementById('plCount').textContent = this.currentPreview.count;
        document.getElementById('plSelected').textContent = this.currentPreview.selected.size;
        listEl.innerHTML = '';

        this.appendPreviewItems(firstData.items || []);
        this.updateStreamLog(firstData.items?.at(-1));
        const totalPages = Math.max(1, Math.ceil(this.currentPreview.count / batchSize));
        for (let p = 2; p <= totalPages; p++){
          if (this.previewAbort) this.previewAbort.abort();
          this.previewAbort = new AbortController();
          const res = await fetch('/api/playlist/preview', {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ url, page: p, pageSize: batchSize }),
            signal: this.previewAbort.signal
          });
          const data = await res.json();
          if (!res.ok) break;
          this.appendPreviewItems(data.items || []);
          this.updateStreamLog(data.items?.at(-1));
        }
        this.currentPreview.streaming = false;
        this.updateStreamLog(null, true);
      }

      appendPreviewItems(items){
        const listEl = document.getElementById('previewList');
        for (const item of items){
          this.currentPreview.items.push(item);
          if (item && Number.isFinite(item.index) && item.id) {
          this.currentPreview.indexToId.set(item.index, item.id);
        }
        if (item && Number.isFinite(item.index) && item.title) {
          this.currentPreview.indexToTitle.set(item.index, item.title);
        }
          const row = document.createElement('div');
          row.className = 'preview-row';
          row.innerHTML = `
            <img class="preview-thumb" src="${item.thumbnail || ''}" alt="thumb" onerror="this.style.display='none'" />
            <div>
              <div class="preview-title">${item.index}. ${this.escapeHtml(item.title || '')}</div>
              <div class="muted">${this.escapeHtml(item.uploader || '')}</div>
            </div>
            <div class="row-right muted">${item.duration_string || (item.duration ? this.formatSeconds(item.duration) : '-')}</div>
            <div class="row-right"><input type="checkbox" data-index="${item.index}" /></div>
          `;
          listEl.appendChild(row);
          const chk = row.querySelector('input[type="checkbox"]');
          chk.checked = this.currentPreview.selected.has(item.index);
          chk.addEventListener('change', (e) => {
            const i = Number(e.target.getAttribute('data-index'));
            if (e.target.checked) this.currentPreview.selected.add(i);
            else this.currentPreview.selected.delete(i);
            document.getElementById('plSelected').textContent = this.currentPreview.selected.size;
            this.updateSelectAllState();
          });
        }
      }

      updateStreamLog(lastItem, done = false){
        const el = document.getElementById('plStreamLog');
        if (!el) return;
        el.style.display = 'block';
        const total = this.currentPreview.items.length;
        if (done) {
          el.textContent = t('ui.streamDone') + ` ‚Ä¢ ${t('ui.totalTracksLoaded', { count: total })}`;
          setTimeout(()=>{ el.style.display = 'none'; }, 2500);
          return;
        }
        if (lastItem) {
          const name = (lastItem?.title || '').toString();
          el.textContent = t('ui.streamAdded') + `: ${name} ‚Ä¢ ${total} / ${this.currentPreview.count}`;
        } else {
          el.textContent = `${t('ui.loading')}‚Ä¶ ${total} / ${this.currentPreview.count}`;
        }
      }

      async loadPage(p, force = false) {
        if (!this.currentPreview.url) return;
        if (this.currentPreview.isSpotify && this.currentPreview.streaming){
          this.showNotification(t('ui.liveModeNoPaging'), 'info');
          return;
        }
        const total = this.currentPreview.count || 0;
        const maxPage = Math.max(1, Math.ceil(total / this.currentPreview.pageSize));
        const next = Math.min(Math.max(1, p), maxPage);
        if (next === this.currentPreview.page && !force) return;
        try {
          const prevBtn = document.getElementById('prevPageBtn');
          const nextBtn = document.getElementById('nextPageBtn');
          prevBtn.disabled = true; nextBtn.disabled = true;
          const listEl = document.getElementById('previewList');
          listEl.innerHTML = `<div class="muted" style="padding:16px">${t('ui.loading')}</div>`;
          if (this.previewAbort) this.previewAbort.abort();
          this.previewAbort = new AbortController();
          const res = await fetch('/api/playlist/preview', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              url: this.currentPreview.url,
              page: next,
              pageSize: this.currentPreview.pageSize
            }),
            signal: this.previewAbort.signal
          });
          const data = await res.json();
          if (!res.ok) {
            const code = data?.error?.code || 'PAGE_FETCH_FAILED';
            throw new Error(t(`errors.${code}`) || t('errors.pageLoadFailed'));
          }
          this.currentPreview.page = data.page || next;
          this.currentPreview.items = data.items || [];
          this.currentPreview.title = data.playlist?.title || this.currentPreview.title;
          this.currentPreview.count = data.playlist?.count ?? this.currentPreview.count;
          document.getElementById('pageNo').textContent = String(this.currentPreview.page);
          this.renderPreview();
        } catch (e) {
          this.showNotification(`${t('notif.errorPrefix')}: ${e.message}`, 'error', 'error');
        } finally {
          const prevBtn = document.getElementById('prevPageBtn');
          const nextBtn = document.getElementById('nextPageBtn');
          prevBtn.disabled = false; nextBtn.disabled = false;
        }
      }

      renderPreview() {
        const listEl = document.getElementById('previewList');
        const titleEl = document.getElementById('plTitle');
        const countEl = document.getElementById('plCount');
        const selectedEl = document.getElementById('plSelected');
        const selectAllEl = document.getElementById('selectAllChk');

        if (this.currentPreview.isSpotify && this.currentPreview.streaming){
          titleEl.textContent = this.currentPreview.title || '-';
          countEl.textContent = this.currentPreview.count;
          selectedEl.textContent = this.currentPreview.selected.size;
          return;
        }

        listEl.innerHTML = '';
        titleEl.textContent = this.currentPreview.title || '-';
        countEl.textContent = this.currentPreview.count;
        selectedEl.textContent = this.currentPreview.selected.size;

        this.currentPreview.items.forEach((item) => {
          if (item && Number.isFinite(item.index) && item.id) {
          this.currentPreview.indexToId.set(item.index, item.id);
        }
        if (item && Number.isFinite(item.index) && item.title) {
          this.currentPreview.indexToTitle.set(item.index, item.title);
        }
          const row = document.createElement('div');
          row.className = 'preview-row';
          row.innerHTML = `
            <img class="preview-thumb" src="${item.thumbnail || ''}" alt="thumb" onerror="this.style.display='none'" />
            <div>
              <div class="preview-title">${item.index}. ${this.escapeHtml(item.title || '')}</div>
              <div class="muted">${this.escapeHtml(item.uploader || '')}</div>
            </div>
            <div class="row-right muted">${item.duration_string || (item.duration ? this.formatSeconds(item.duration) : '-')}</div>
            <div class="row-right"><input type="checkbox" data-index="${item.index}" /></div>
          `;
          listEl.appendChild(row);
        });

        listEl.querySelectorAll('input[type="checkbox"]').forEach((chk) => {
          const idx = Number(chk.getAttribute('data-index'));
          chk.checked = this.currentPreview.selected.has(idx);
          chk.addEventListener('change', (e) => {
            const i = Number(e.target.getAttribute('data-index'));
            if (e.target.checked) this.currentPreview.selected.add(i);
            else this.currentPreview.selected.delete(i);
            document.getElementById('plSelected').textContent = this.currentPreview.selected.size;
            this.updateSelectAllState();
          });
        });

        this.updateSelectAllState();
      }

      updateSelectAllState() {
        const listEl = document.getElementById('previewList');
        const chks = [...listEl.querySelectorAll('input[type="checkbox"]')];
        const totalVisible = chks.length;
        const selectedVisible = chks.filter(c => c.checked).length;
        const allEl = document.getElementById('selectAllChk');

        if (totalVisible === 0) {
          allEl.checked = false;
          allEl.indeterminate = false;
          return;
        }
        if (selectedVisible === 0) {
          allEl.checked = false;
          allEl.indeterminate = false;
        } else if (selectedVisible === totalVisible) {
          allEl.checked = true;
          allEl.indeterminate = false;
        } else {
          allEl.checked = false;
          allEl.indeterminate = true;
        }

        document.getElementById('plSelected').textContent = this.currentPreview.selected.size;
      }

      toggleSelectAll(flag) {
        const listEl = document.getElementById('previewList');
        const chks = listEl.querySelectorAll('input[type="checkbox"]');
        chks.forEach((chk) => {
          const idx = Number(chk.getAttribute('data-index'));
          chk.checked = !!flag;
          if (flag) this.currentPreview.selected.add(idx);
          else this.currentPreview.selected.delete(idx);
        });
        this.updateSelectAllState();
      }

      async convertSelected() {
  if (!this.currentPreview.url) {
    this.showNotification(t('notif.previewFirst'), 'error', 'error');
    return;
  }

  const selected = Array.from(this.currentPreview.selected);
  if (!selected.length) {
    this.showNotification(t('notif.selectAtLeastOne'), 'error', 'error');
    return;
  }

  const convertBtn = document.getElementById('convertSelectedBtn');
  const originalText = convertBtn.textContent;

  try {
    convertBtn.classList.add('btn-loading');
    convertBtn.disabled = true;
    convertBtn.textContent = t('ui.processing') || 'ƒ∞≈üleniyor...';

    const format = document.getElementById('formatSelect').value;
    const bitrate = document.getElementById('bitrateSelect').value;
    const sampleRate = document.getElementById('sampleRateSelect').value;
    const sequential = document.getElementById('sequentialChk')?.checked;
    const includeLyrics = document.getElementById('lyricsCheckbox').checked;
    const selectedIds = selected
      .map(i => this.currentPreview.indexToId.get(i))
      .filter(Boolean);

    console.log("Se√ßilen ID'ler:", selectedIds);

    if (sequential && selected.length > 1) {
      const batchId = `b${Date.now().toString(36)}${Math.random().toString(36).slice(2,7)}`;
      this.ensureBatch(batchId, selected.length, { format, bitrate, source: t('ui.youtubePlaylist') });
      for (const idx of selected) {
        const idFromMap = this.currentPreview.indexToId.get(idx);
        const itemId = idFromMap ? [idFromMap] : null;

        await this.submitJob({
          url: this.currentPreview.url,
          isPlaylist: true,
          selectedIndices: [idx],
          selectedIds: itemId,
          format,
          bitrate,
          sampleRate: sampleRate,
          clientBatch: batchId,
          includeLyrics
        });
      }
    } else {
      await this.submitJob({
        url: this.currentPreview.url,
        isPlaylist: true,
        selectedIndices: selected,
        selectedIds: selectedIds.length ? selectedIds : null,
        format,
        bitrate,
        sampleRate: sampleRate,
        includeLyrics
      });
    }

    this.showNotification(t('notif.tracksQueued', { count: selected.length }), 'success', 'queue');

  } catch (error) {
    console.error('Se√ßilenleri d√∂n√º≈üt√ºrme hatasƒ±:', error);
    this.showNotification(`${t('notif.conversionError')}: ${error.message}`, 'error', 'error');
  } finally {
    convertBtn.classList.remove('btn-loading');
    convertBtn.disabled = false;
    convertBtn.textContent = originalText;
  }
}

      async convertAll() {
  if (!this.currentPreview.url) {
    this.showNotification(t('notif.previewFirst'), 'error', 'error');
    return;
  }

  const convertAllBtn = document.getElementById('convertAllBtn');
  const originalText = convertAllBtn.textContent;

  try {
    convertAllBtn.classList.add('btn-loading');
    convertAllBtn.disabled = true;
    convertAllBtn.textContent = t('ui.processing') || 'ƒ∞≈üleniyor...';

    const format = document.getElementById('formatSelect').value;
    const bitrate = document.getElementById('bitrateSelect').value;
    const sampleRate = document.getElementById('sampleRateSelect').value;
    const includeLyrics = document.getElementById('lyricsCheckbox').checked;
    const allIds = this.currentPreview.items.map(item => item.id).filter(Boolean);

    await this.submitJob({
      url: this.currentPreview.url,
      isPlaylist: true,
      selectedIndices: 'all',
      selectedIds: allIds,
      format,
      bitrate,
      sampleRate: sampleRate,
      includeLyrics
    });

    this.showNotification(t('notif.allTracksQueued'), 'success', 'queue');

  } catch (error) {
    console.error('T√ºm√ºn√º d√∂n√º≈üt√ºrme hatasƒ±:', error);
    this.showNotification(`${t('notif.conversionError')}: ${error.message}`, 'error', 'error');
  } finally {
    convertAllBtn.classList.remove('btn-loading');
    convertAllBtn.disabled = false;
    convertAllBtn.textContent = originalText;
  }
}

      showPreview() {
      document.getElementById('spotifyPreviewCard').style.display = 'none';
      document.getElementById('playlistPreviewCard').style.display = 'block';
    }

      hidePreview() {
        document.getElementById('playlistPreviewCard').style.display = 'none';
        const spotifyCard = document.getElementById('spotifyPreviewCard');
        spotifyCard.style.display = 'none';
        document.getElementById('spotifyLogs').innerHTML = '';
        document.getElementById('spotifyPreviewList').innerHTML = '';

        const convertMatchedBtn = document.getElementById('convertMatchedBtn');
        if (convertMatchedBtn) {
          convertMatchedBtn.style.display = 'none';
        }

        if (this.spotifyEventSource) {
          this.spotifyEventSource.close();
          this.spotifyEventSource = null;
        }
        if (this.previewAbort) {
          try { this.previewAbort.abort(); } catch {}
          this.previewAbort = null;
        }

        this.currentPreview = {
        url: null, items: [], selected: new Set(),
        title: '', count: 0, page: 1, pageSize: 50,
        isSpotify: false, streaming: false,
        indexToId: new Map(),
        indexToTitle: new Map()
        };
        this.currentSpotifyTask = {
          id: null,
          jobId: null,
          completed: false
        };

        const logEl = document.getElementById('plStreamLog');
        if (logEl) { logEl.style.display='none'; logEl.textContent=''; }
      }

      showQueueNotification(message) {
          this.showNotification(message, 'success', 'queue');
      }

      showErrorNotification(message) {
          this.showNotification(message, 'error', 'error');
      }

      showProgressNotification(message) {
          this.showNotification(message, 'info', 'progress');
      }

      showNotification(message, type = 'info', group = 'default') {
        this.notificationManager.showNotification(message, type, group, 3000);
      }

      normalizeBackendLog(txt) {
        if (txt == null) return '';
        try { txt = String(txt); } catch { return ''; }
        txt = txt.replace(/^SKIP_HINT:\s*/i, '');
        txt = txt.replace(/^SKIP_SUMMARY:\s*/i, '');
        if (txt.startsWith('log.') || txt.startsWith('phase.') || txt.startsWith('status.')) {
          try { return t(txt); } catch {  }
        }
        return txt.replace(/\s+/g, ' ').trim();
      }

      escapeHtml(str) {
        if (str == null) return "";
        if (typeof str === "object") {
        const key  = str.key || str.logKey || null;
        const vars = str.vars || str.logVars || null;
        const txt  = str.text || str.fallback || "";
        if (key && typeof this.t === "function") {
          try { str = this.t(key, vars || {}) ?? txt ?? key; }
          catch { str = txt || key || ""; }
        } else {
            try { str = txt || JSON.stringify(str); } catch { str = String(str); }
          }
        }
        str = String(str);
        return str.replace(/[&<>"'`=\/]/g, s => this._escapeMap[s] || s);
    }

      formatSeconds(sec) {
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = Math.floor(sec % 60);
        return (h ? h.toString().padStart(2,'0')+':' : '') + m.toString().padStart(2,'0') + ':' + s.toString().padStart(2,'0');
      }

       async cancelBatch(batchId) {
        const batch = this.batches.get(batchId);
        if (!batch) return;
        const ids = Array.from(batch.jobs || []);
        if (!ids.length) return;

        const stopBtn = document.querySelector(`[data-stop-batch="${batchId}"]`);
        if (stopBtn) stopBtn.disabled = true;

        const tasks = ids.map(async (id) => {
          const j = this.jobStates.get(id);
          const s = this.normalizeStatus(j?.status);
          if (!j || ['completed','error','canceled'].includes(s)) return;
          try {
            const r = await fetch(`/api/jobs/${encodeURIComponent(id)}/cancel`, { method: 'POST' });
            if (r.ok) {
              const js = this.jobStates.get(id) || {};
              js.status = 'canceled';
              js.phase = 'canceled';
              js.currentPhase = 'canceled';
              this.jobStates.set(id, js);
              this.updateJobUI(js, batchId);
            }
          } catch (_) {}
        });

        await Promise.allSettled(tasks);
        this.updateBatchProgress(batchId);
        this.showNotification(t('notif.canceledByUser') || 'Batch iptal edildi', 'success', 'action');
      }
      async handleUrlSubmitWithSpinner(e) {
        e.preventDefault();

        const startConvertBtn =
          document.getElementById('startConvertBtn') ||
          document.querySelector('#urlForm [type="submit"]');
        const spinner = startConvertBtn?.querySelector('.btn-spinner') || null;
        const btnText = startConvertBtn?.querySelector('.btn-text') || null;
        this.showButtonSpinner(startConvertBtn, spinner, btnText);

        try {
          const waitFirstUpdate = new Promise((resolve) => {
                const onFirst = () => resolve();
                const timeout = setTimeout(resolve, 15000);
                document.addEventListener('job:first-update', function handler() {
                    clearTimeout(timeout);
                    document.removeEventListener('job:first-update', handler);
                    onFirst();
                }, { once: true });
            });

            await this.handleUrlSubmit(e);
            await waitFirstUpdate;
        } catch (error) {
            console.error('URL g√∂nderme hatasƒ±:', error);
            this.showNotification(`${t('notif.errorPrefix')}: ${error.message}`, 'error', 'error');
        } finally {
            this.hideButtonSpinner(startConvertBtn, startConvertBtn?.querySelector('.btn-spinner') || null, startConvertBtn?.querySelector('.btn-text') || null);
        }
      }

      showButtonSpinner(button, spinner, btnText) {
        if (!button) return;
        if (!spinner) {
          const sp = document.createElement('span');
          sp.className = 'btn-spinner';
          sp.style.display = 'inline-block';
          sp.style.marginRight = '6px';
          button.prepend(sp);
          spinner = sp;
        }
        if (!btnText) {
          const textNodes = [];
          button.childNodes.forEach(n => {
            if (n.nodeType === 3 && n.textContent.trim()) textNodes.push(n);
          });
          const txt = document.createElement('span');
          txt.className = 'btn-text';
          if (textNodes.length) {
            const raw = textNodes.map(n => n.textContent).join(' ').replace(/\s+/g,' ').trim();
            if (raw) txt.textContent = raw;
          }
          textNodes.forEach(n => n.remove());
          button.appendChild(txt);
          btnText = txt;
        }
        button.classList.add('btn-loading');
        if (spinner) spinner.style.display = 'inline-block';
        button.disabled = true;
      }

      hideButtonSpinner(button, spinner, btnText) {
        if (!button) return;
        button.classList.remove('btn-loading');
        if (spinner) spinner.style.display = 'none';
        button.disabled = false;
      }
    }

    function t(key, vars) {
      if (typeof key === 'string' && key.startsWith('log.download.')) {
        const fixed = key.replace('log.download.', 'log.downloading.');
        const out = window.i18n?.t?.(fixed, vars);
        if (out && out !== fixed) return out;
      }
      return (window.i18n?.t?.(key, vars)) ?? key;
    }

    document.addEventListener('DOMContentLoaded', async () => {
      try { await window.i18nInit(); } catch {}
      new MediaConverterApp();
      const tokenKey = "gharmonize_admin_token";
      const settingsBtn = document.getElementById('settingsBtn');
      settingsBtn.addEventListener('click', openSettingsModal);

      function ensureModal() {
        if (document.getElementById('settingsModal')) return;
        const wrap = document.createElement('div');
        wrap.id = 'settingsModal';
        wrap.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:9999;';
        wrap.innerHTML = `
          <div class="settings-dialog">
            <div class="settings-dialog__header">
              <h3 data-i18n="settings.title">Ayarlar</h3>
              <button id="settingsClose" class="btn-outline">‚úñ</button>
            </div>
            <div id="settingsBody" class="settings-dialog__body">
              <div id="loginView">
                <label class="settings-field-label" data-i18n="settings.adminPassword">Y√∂netici ≈ûifresi</label>
                <input id="adminPass" type="password" class="settings-input" autofocus />
                <div id="adminError" class="settings-error" aria-live="polite" style="display:none"></div>
                <div class="settings-actions settings-actions--end">
                  <button id="loginBtn" class="btn-primary" data-i18n="btn.login">Giri≈ü yap</button>
                </div>
              </div>
              <div id="formView" style="display:none">
                <div class="form-group">
                  <label data-i18n="settings.spotifyClientId">SPOTIFY_CLIENT_ID</label>
                  <input id="f_SPOTIFY_CLIENT_ID" type="text" >
                </div>
                <div class="form-group">
                  <label data-i18n="settings.spotifyClientSecret">SPOTIFY_CLIENT_SECRET</label>
                  <input id="f_SPOTIFY_CLIENT_SECRET" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" data-i18n-ph="ph.spotifyClientSecret" >
                </div>
                <div class="form-group">
                  <label data-i18n="settings.spotifyMarket">SPOTIFY_MARKET</label>
                  <input id="f_SPOTIFY_MARKET" type="text" placeholder="TR, US, GB vb." data-i18n-ph="ph.spotifyMarket" >
                </div>
                <div class="form-group">
                  <label data-i18n="settings.spotifyFallbackMarkets">SPOTIFY_FALLBACK_MARKETS</label>
                  <input id="f_SPOTIFY_FALLBACK_MARKETS" type="text" placeholder="US,GB,DE,FR" data-i18n-ph="ph.spotifyFallbackMarkets" >
                </div>
                <div class="form-group">
                  <label data-i18n="settings.ytUseMusic">YT_USE_MUSIC</label>
                  <select id="f_YT_USE_MUSIC">
                    <option value="1">1</option>
                    <option value="0">0</option>
                  </select>
                </div>
                <div class="form-group">
                  <label data-i18n="settings.preferSpotifyTags">PREFER_SPOTIFY_TAGS</label>
                  <select id="f_PREFER_SPOTIFY_TAGS">
                    <option value="1">1</option>
                    <option value="0">0</option>
                  </select>
                </div>
                <div class="form-group">
                  <label data-i18n="settings.titleCleanPipe">TITLE_CLEAN_PIPE</label>
                  <select id="f_TITLE_CLEAN_PIPE">
                    <option value="1">1</option>
                    <option value="0">0</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>YT_DEFAULT_REGION</label>
                  <input id="f_YT_DEFAULT_REGION" type="text" placeholder="√∂r: TR, US (bo≈ü = kapalƒ±)" data-i18n-ph="ph.ytDefaultRegion" >
                </div>
                <div class="form-group">
                  <label>YT_LANG</label>
                  <input id="f_YT_LANG" type="text" placeholder="en-US, tr-TR ..." data-i18n-ph="ph.ytLang" >
                </div>
                <div class="form-group">
                  <label>YT_ACCEPT_LANGUAGE</label>
                  <input id="f_YT_ACCEPT_LANGUAGE" type="text" placeholder="en-US,en;q=0.8 (opsiyonel)" data-i18n-ph="ph.ytAcceptLang" >
                </div>
                <div class="form-group">
                  <label>YT_FORCE_IPV4</label>
                  <select id="f_YT_FORCE_IPV4">
                    <option value="1">1</option>
                    <option value="0">0</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>YT_403_WORKAROUNDS</label>
                  <select id="f_YT_403_WORKAROUNDS">
                    <option value="1">1</option>
                    <option value="0">0</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>YTDLP_UA</label>
                  <input id="f_YTDLP_UA" type="text" placeholder="User-Agent (opsiyonel)" data-i18n-ph="ph.ytdlpUA" >
                </div>
                <div class="form-group">
                  <label>YTDLP_COOKIES</label>
                  <input id="f_YTDLP_COOKIES" type="text" placeholder="/path/to/cookies.txt (opsiyonel)" data-i18n-ph="ph.ytdlpCookies" >
                </div>
                <div class="form-group">
                  <label>YTDLP_COOKIES_FROM_BROWSER</label>
                  <select id="f_YTDLP_COOKIES_FROM_BROWSER">
                    <option value="">(kapalƒ±)</option>
                    <option value="chrome">chrome</option>
                    <option value="chromium">chromium</option>
                    <option value="firefox">firefox</option>
                    <option value="edge">edge</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>YTDLP_EXTRA</label>
                  <input id="f_YTDLP_EXTRA" type="text" placeholder="Ek arg√ºmanlar, √∂r: --http-chunk-size 10M" data-i18n-ph="ph.ytdlpExtra" >
                </div>
                <div class="form-group">
                  <label>YT_STRIP_COOKIES</label>
                  <select id="f_YT_STRIP_COOKIES">
                    <option value="0">0</option>
                    <option value="1">1</option>
                  </select>
                </div>
                <h4 class="settings-section-title" data-i18n="settings.adminPassword">Y√∂netici ≈ûifresi</h4>
                <div class="form-group">
                  <label class="settings-field-label" data-i18n="settings.currentPassword">Eski ≈ûifre</label>
                  <input id="f_ADMIN_OLD" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" data-i18n-ph="settings.currentPassword" />
                </div>
                <div class="form-group">
                  <label class="settings-field-label" data-i18n="settings.newPassword">Yeni ≈ûifre</label>
                  <input id="f_ADMIN_NEW" type="password" placeholder="En az 6 karakter" data-i18n-ph="settings.newPassword" />
                </div>
                <div class="form-group">
                  <label class="settings-field-label" data-i18n="settings.newPassword2">Yeni ≈ûifre (Tekrar)</label>
                  <input id="f_ADMIN_NEW2" type="password" placeholder="Yeni ≈ûifre (Tekrar)" data-i18n-ph="settings.newPassword2" />
                </div>
                <div class="settings-actions settings-actions--end">
                  <button id="changePassBtn" class="btn-primary" data-i18n="btn.changePassword">≈ûifreyi G√ºncelle</button>
                </div>
                <div class="settings-actions settings-actions--between">
                  <button id="logoutBtn" class="btn-outline" data-i18n="btn.logout">√áƒ±kƒ±≈ü</button>
                  <div class="settings-actions__right">
                    <button id="reloadBtn" class="btn-outline" data-i18n="btn.reload">Yenile</button>
                    <button id="saveBtn" class="btn-primary" data-i18n="btn.save">Kaydet</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>`;
        document.body.appendChild(wrap);
        document.getElementById('settingsClose').onclick = closeSettingsModal;
        document.getElementById('loginBtn').onclick = doLogin;
        document.getElementById('logoutBtn').onclick = doLogout;
        document.getElementById('reloadBtn').onclick = loadSettings;
        document.getElementById('saveBtn').onclick = saveSettings;
        document.getElementById('changePassBtn').onclick = changePassword;
        window.i18n?.apply?.(wrap);
      }

      function openSettingsModal(){
        ensureModal();
        const modal = document.getElementById('settingsModal');
        modal.style.display = 'flex';
        const passEl = document.getElementById('adminPass');
        const loginBtn = document.getElementById('loginBtn');
        const onEnter = (e) => {
           if (e.key === 'Enter') {
             e.preventDefault();
             loginBtn?.click();
           }
         };
        passEl?.addEventListener('keydown', onEnter, { passive: false });
        const token = localStorage.getItem(tokenKey);
        if (token) {
          showForm();
          loadSettings();
        } else {
          showLogin();
          requestAnimationFrame(() => document.getElementById('adminPass')?.focus());
        }
      }

      function closeSettingsModal(){
        const modal = document.getElementById('settingsModal');
        if (modal) modal.style.display = 'none';
      }

      function showLogin(){
        document.getElementById('loginView').style.display = 'flex';
        document.getElementById('formView').style.display = 'none';
        document.getElementById('adminPass').value = '';
        requestAnimationFrame(() => document.getElementById('adminPass')?.focus());
      }

      function showForm(){
        document.getElementById('loginView').style.display = 'none';
        document.getElementById('formView').style.display = 'block';
      }

      async function doLogin(){
        const password = document.getElementById('adminPass').value;
        const errEl = document.getElementById('adminError');
        const btn = document.getElementById('loginBtn');
        const passEl = document.getElementById('adminPass');
        if (errEl) { errEl.style.display = 'none'; errEl.textContent = ''; }

        if (!password) {
          if (errEl) { errEl.textContent = t?.('errors.emptyPassword') || 'L√ºtfen ≈üifreyi girin.'; errEl.style.display = 'block'; }
          passEl?.focus();
          return;
        }
        try {
        btn?.classList.add('btn-loading');
        btn && (btn.disabled = true);
          const r = await fetch('/api/auth/login', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ password })
          });
          if (!r.ok) {
            const e = await r.json().catch(()=>({}));
            const code = e?.error?.code;
            let msg =
              (code === 'BAD_PASSWORD') ? (t?.('errors.BAD_PASSWORD') || 'Hatalƒ± ≈üifre.') :
              (code === 'NO_ADMIN_PASSWORD') ? (t?.('errors.NO_ADMIN_PASSWORD') || 'Sunucuda ADMIN_PASSWORD tanƒ±mlƒ± deƒüil.') :
              (e?.error?.message || t?.('errors.loginFailed') || 'Giri≈ü yapƒ±lamadƒ±.');
            throw new Error(msg);
          }
          const data = await r.json();
          localStorage.setItem(tokenKey, data.token);
          window.dispatchEvent(new CustomEvent('gharmonize:auth', { detail: { loggedIn: true } }));
          showForm();
          await loadSettings();
        }catch(e){
          if (errEl) { errEl.textContent = String(e.message || 'Giri≈ü hatasƒ±'); errEl.style.display = 'block'; }
          passEl?.classList.add('shake');
          setTimeout(()=> passEl?.classList.remove('shake'), 350);
          passEl?.focus();
        } finally {
          btn?.classList.remove('btn-loading');
          btn && (btn.disabled = false);
        }
      }

      async function doLogout(){
        localStorage.removeItem(tokenKey);
        window.dispatchEvent(new CustomEvent('gharmonize:auth', { detail: { loggedIn: false } }));
        showLogin();
        requestAnimationFrame(() => document.getElementById('adminPass')?.focus());
      }

      async function loadSettings(){
        const token = localStorage.getItem(tokenKey) || "";
        try{
          const r = await fetch('/api/settings', { headers: { 'Authorization': 'Bearer ' + token }});
          if (r.status === 401) { showLogin(); return; }
          const data = await r.json();
          const s = data.settings || {};
          document.getElementById('f_SPOTIFY_CLIENT_ID').value = s.SPOTIFY_CLIENT_ID || '';
          document.getElementById('f_SPOTIFY_CLIENT_SECRET').value = '';
          document.getElementById('f_SPOTIFY_MARKET').value = s.SPOTIFY_MARKET || '';
          document.getElementById('f_SPOTIFY_FALLBACK_MARKETS').value = s.SPOTIFY_FALLBACK_MARKETS || '';
          document.getElementById('f_YT_USE_MUSIC').value = s.YT_USE_MUSIC || '1';
          document.getElementById('f_PREFER_SPOTIFY_TAGS').value = s.PREFER_SPOTIFY_TAGS || '1';
          document.getElementById('f_TITLE_CLEAN_PIPE').value = s.TITLE_CLEAN_PIPE || '1';
          document.getElementById('f_YTDLP_UA').value = s.YTDLP_UA || '';
          document.getElementById('f_YTDLP_COOKIES').value = s.YTDLP_COOKIES || '';
          document.getElementById('f_YTDLP_COOKIES_FROM_BROWSER').value = s.YTDLP_COOKIES_FROM_BROWSER || '';
          document.getElementById('f_YTDLP_EXTRA').value = s.YTDLP_EXTRA || '';
          document.getElementById('f_YT_STRIP_COOKIES').value = (typeof s.YT_STRIP_COOKIES !== 'undefined' && s.YT_STRIP_COOKIES !== null)
            ? String(s.YT_STRIP_COOKIES)
            : '0';
            document.getElementById('f_YT_DEFAULT_REGION').value = s.YT_DEFAULT_REGION || '';
            document.getElementById('f_YT_LANG').value = s.YT_LANG || 'en-US';
            document.getElementById('f_YT_ACCEPT_LANGUAGE').value = s.YT_ACCEPT_LANGUAGE || '';
            document.getElementById('f_YT_FORCE_IPV4').value = (typeof s.YT_FORCE_IPV4 !== 'undefined' && s.YT_FORCE_IPV4 !== null) ? String(s.YT_FORCE_IPV4) : '1';
            document.getElementById('f_YT_403_WORKAROUNDS').value = (typeof s.YT_403_WORKAROUNDS !== 'undefined' && s.YT_403_WORKAROUNDS !== null) ? String(s.YT_403_WORKAROUNDS) : '1';
        }catch(e){
          alert(t('settings.errorLoading') + ': ' + e.message);
        }
      }

      async function saveSettings(){
        const token = localStorage.getItem(tokenKey) || "";
        const payload = {
          settings: {
            SPOTIFY_CLIENT_ID: document.getElementById('f_SPOTIFY_CLIENT_ID').value.trim(),
            SPOTIFY_CLIENT_SECRET: document.getElementById('f_SPOTIFY_CLIENT_SECRET').value.trim(),
            SPOTIFY_MARKET: document.getElementById('f_SPOTIFY_MARKET').value.trim(),
            SPOTIFY_FALLBACK_MARKETS: document.getElementById('f_SPOTIFY_FALLBACK_MARKETS').value.trim(),
            YT_USE_MUSIC: document.getElementById('f_YT_USE_MUSIC').value,
            PREFER_SPOTIFY_TAGS: document.getElementById('f_PREFER_SPOTIFY_TAGS').value,
            TITLE_CLEAN_PIPE: document.getElementById('f_TITLE_CLEAN_PIPE').value,
            YTDLP_UA: document.getElementById('f_YTDLP_UA').value,
            YTDLP_COOKIES: document.getElementById('f_YTDLP_COOKIES').value,
            YTDLP_COOKIES_FROM_BROWSER: document.getElementById('f_YTDLP_COOKIES_FROM_BROWSER').value,
            YTDLP_EXTRA: document.getElementById('f_YTDLP_EXTRA').value,
            YT_STRIP_COOKIES: document.getElementById('f_YT_STRIP_COOKIES').value,
            YT_DEFAULT_REGION: document.getElementById('f_YT_DEFAULT_REGION').value.trim(),
            YT_LANG: document.getElementById('f_YT_LANG').value.trim(),
            YT_ACCEPT_LANGUAGE: document.getElementById('f_YT_ACCEPT_LANGUAGE').value.trim(),
            YT_FORCE_IPV4: document.getElementById('f_YT_FORCE_IPV4').value,
            YT_403_WORKAROUNDS: document.getElementById('f_YT_403_WORKAROUNDS').value
          }
        };
        try{
          const r = await fetch('/api/settings', {
            method:'POST',
            headers:{ 'Content-Type':'application/json', 'Authorization': 'Bearer ' + token },
            body: JSON.stringify(payload)
          });
          if (r.status === 401) { showLogin(); return; }
          if (!r.ok) {
            const e = await r.json().catch(()=>({}));
            throw new Error(e?.error?.message || t('errors.saveFailed'));
          }
          alert(t('settings.saved'));
        }catch(e){
          alert(t('settings.errorSaving') + ': ' + e.message);
        }
      }

      async function changePassword(){
      const token = localStorage.getItem(tokenKey) || "";
      const oldPassword = document.getElementById('f_ADMIN_OLD').value;
      const newPassword = document.getElementById('f_ADMIN_NEW').value;
      const newPassword2 = document.getElementById('f_ADMIN_NEW2').value;

      if (!oldPassword || !newPassword || !newPassword2) {
        alert((t && t('settings.errors.fieldsRequired')) || 'T√ºm alanlar zorunludur.');
        return;
      }
      if (newPassword !== newPassword2) {
        alert((t && t('settings.errors.passwordMismatch')) || 'Yeni ≈üifreler e≈üle≈ümiyor.');
        return;
      }
      if (String(newPassword).length < 6) {
        alert((t && t('settings.errors.passwordTooShort')) || 'Yeni ≈üifre en az 6 karakter olmalƒ±dƒ±r.');
        return;
      }

      try {
        const r = await fetch('/api/auth/change-password', {
          method:'POST',
          headers:{ 'Content-Type':'application/json', 'Authorization': 'Bearer ' + token },
          body: JSON.stringify({ oldPassword, newPassword, newPassword2 })
        });

        if (!r.ok) {
          const e = await r.json().catch(()=>({}));
          const code = e?.error?.code;
          const map = {
            BAD_PASSWORD: 'errors.BAD_PASSWORD2',
            PASSWORD_MISMATCH: 'errors.PASSWORD_MISMATCH',
            PASSWORD_TOO_SHORT: 'errors.PASSWORD_TOO_SHORT',
            FIELDS_REQUIRED: 'errors.FIELDS_REQUIRED',
            PASSWORD_SAVE_FAILED: 'errors.PASSWORD_SAVE_FAILED',
            UNAUTHORIZED: 'errors.UNAUTHORIZED'
          };
          const key = map[code] || 'errors.changePasswordFailed';
          const msg = (t && t(key)) || (e?.error?.message || '≈ûifre deƒüi≈ütirilemedi.');
          throw new Error(msg);
        }

        const data = await r.json();
        alert((t && t('settings.passwordChanged')) || '≈ûifre g√ºncellendi. L√ºtfen yeniden giri≈ü yapƒ±n.');
        if (data.logout) {
          localStorage.removeItem(tokenKey);
          window.dispatchEvent(new CustomEvent('gharmonize:auth', { detail: { loggedIn: false } }));
          document.getElementById('f_ADMIN_OLD').value = '';
          document.getElementById('f_ADMIN_NEW').value = '';
          document.getElementById('f_ADMIN_NEW2').value = '';
          showLogin();
        }
      } catch (e) {
          alert(String(e.message || '≈ûifre deƒüi≈ütirilemedi.'));
        }
      }
    });

    document.addEventListener('DOMContentLoaded', () => {
    const title = document.querySelector('.title-section');
    const container = document.querySelector('.container');
    const firstCard = document.querySelector('.card-grid .card:first-child');

    if (!title || !container || !firstCard) return;
    const GAP = 8;

    function placeTitle() {
    const cont = container.getBoundingClientRect();
    const card = firstCard.getBoundingClientRect();
      title.style.visibility = 'hidden';
      title.style.left = '0px';
      title.style.top = '0px';
      const titleH = title.offsetHeight;
      const left = card.left - cont.left;
      const top  = card.top  - cont.top  - titleH - GAP;

      title.style.left = left + 'px';
      title.style.top  = top  + 'px';
      title.style.visibility = 'visible';
    }

    placeTitle();
    window.addEventListener('resize', placeTitle, { passive: true });
    window.addEventListener('scroll', placeTitle, { passive: true });
    new ResizeObserver(placeTitle).observe(document.documentElement);
  });

(function(){
      const tokenKey = "gharmonize_admin_token";
      const bell = document.getElementById('jobsBell');
      const badge = document.getElementById('jobsBadge');
      const panel = document.getElementById('jobsPanel');
      const overlay = document.getElementById('jobsOverlay');
      const list = document.getElementById('jobsList');
      const emptyState = document.getElementById('jobsPanelEmpty');
      const fActive = document.getElementById('jobsFilterActive');
      const fAll = document.getElementById('jobsFilterAll');
      const btnClose = document.getElementById('jobsClose');

      let state = { items: [] };
      let filter = 'active';
      let es = null;
      let started = false;

      function norm(s){
        const v = String(s || '').toLowerCase();
        return v === 'cancelled' ? 'canceled' : v;
      }

      function start() {
        if (started) return;
        started = true;
        bell?.addEventListener('click', ()=>{
          panel.setAttribute('aria-hidden','false');
          overlay.hidden=false;
        });
        overlay?.addEventListener('click', ()=>{
          panel.setAttribute('aria-hidden','true');
          overlay.hidden=true;
        });
        btnClose?.addEventListener('click', ()=>{
          panel.setAttribute('aria-hidden','true');
          overlay.hidden=true;
        });
        fActive?.addEventListener('click', ()=>{
          filter='active';
          fActive.classList.add('chip--active');
          fAll.classList.remove('chip--active');
          render();
        });
        fAll?.addEventListener('click', ()=>{
          filter='all';
          fAll.classList.add('chip--active');
          fActive.classList.remove('chip--active');
          render();
        });
      }

      function goOnline() {
        bell.hidden = false;
        try { es?.close?.(); } catch {}
        startSSE();
      }

      function goOffline() {
        bell.hidden = true;
        panel.setAttribute('aria-hidden','true');
        overlay.hidden = true;
        try { es?.close?.(); } catch {}
        es = null;
        state = { items: [] };
        render();
      }

      start();
      if (localStorage.getItem(tokenKey)) goOnline(); else goOffline();

      window.addEventListener('gharmonize:auth', (ev)=>{
        const on = !!ev?.detail?.loggedIn;
        if (on) goOnline(); else goOffline();
      });

      window.addEventListener('storage', (ev)=>{
        if (ev.key !== tokenKey) return;
        if (ev.newValue) goOnline(); else goOffline();
      });

      function titleOf(j){
        const m = j.metadata || {}; const ex = m.extracted || {};
        return m.frozenTitle || m.spotifyTitle || ex.title || m.originalName ||
               (m.isAutomix ? t('jobsPanel.automix') : (m.isPlaylist ? t('jobsPanel.playlist') : t('jobsPanel.job')));
      }

      function sourcePill(j){
        const s = j.metadata?.source || 'file';
        const sources = {
          youtube: t('jobsPanel.sourceYouTube'),
          spotify: t('jobsPanel.sourceSpotify'),
          direct_url: t('jobsPanel.sourceURL'),
          file: t('jobsPanel.sourceFile')
        };
        return sources[s] || s;
      }

      function phasePill(j){
        const p = norm(j.currentPhase || j.status);
        const map = {
          preparing: t('phase.preparing'),
          downloading: t('phase.downloading'),
          converting: t('phase.converting'),
          completed: t('phase.completed'),
          error: t('phase.error'),
          canceled: t('status.canceled'),
          cancelled: t('status.canceled')
        };
        return map[p] || (j.currentPhase || j.status);
      }

      function statusDot(j){
        const s = norm(j.status);
        if (s==='error') return '<span class="dot status-err">‚óè</span>';
        if (s==='completed') return '<span class="dot status-ok">‚óè</span>';
        if (s==='canceled') return '<span class="dot status-warn">‚óè</span>';
        return '<span class="dot status-warn">‚óè</span>';
      }

      function prog(j){
        if (typeof j.progress==='number') return j.progress;
        const d=j.downloadProgress||0, c=j.convertProgress||0;
        return Math.floor((d+c)/2);
      }

      function currentIndex(j) {
        const total = j.playlist?.total;
        const done  = j.playlist?.done;
        if (Number.isFinite(total) && Number.isFinite(done) && total > 0) {
          const idx0 = Math.min(Math.max(0, done || 0), Math.max(0, total - 1));
          return idx0;
        }
        return null;
      }

      function nowTitle(j){
        if (j.metadata?.isPlaylist && Array.isArray(j.metadata?.frozenEntries) && j.metadata.frozenEntries.length) {
          const i0 = currentIndex(j);
          if (i0 !== null && j.metadata.frozenEntries[i0]) {
            return `${j.metadata.frozenEntries[i0].index}. ${j.metadata.frozenEntries[i0].title}`;
          }
        }
        const ex = j.metadata?.extracted || {};
        return ex.track || ex.title || j.metadata?.originalName || null;
      }

      function computeSkippedPanel(j){
        const direct = Number(j?.skippedCount ?? j?.metadata?.skippedCount ?? 0);
        if (direct > 0) return direct;

        if (Number.isFinite(j?.playlist?.skipped))
        return Number(j.playlist.skipped);

        if (j?.metadata?.isPlaylist && Array.isArray(j?.resultPath)) {
          const successful = j.resultPath.filter(r => r && r.outputPath && !r.error).length;
          const total = Number(j?.playlist?.total ?? j?.metadata?.frozenEntries?.length ?? successful);
          return Math.max(0, total - successful);
        }
        return 0;
        }

      function render(){
        const allItems = state.items.slice();
        const items = (filter==='active')
         ? allItems.filter(j => !['completed','error','canceled'].includes(norm(j.status)))
         : allItems;

        const activeCount = allItems.filter(j => !['completed','error','canceled'].includes(norm(j.status))).length;
        badge.textContent = String(activeCount);
        badge.hidden = activeCount <= 0;

        if (items.length === 0) {
          const isActive = (filter === 'active');
          list.innerHTML = `
            <div class="jobs-panel__empty">
             <div class="jobs-panel__empty-icon">üéµ</div>
              <div class="jobs-panel__empty-title">
                ${isActive ? t('jobsPanel.emptyActive') : t('jobs.empty')}
              </div>
              <div class="jobs-panel__empty-subtitle">
                ${isActive ? t('jobsPanel.emptyDescriptionActive') : t('jobsPanel.emptyDescriptionAll')}
              </div>
              <div class="jobs-panel__empty-actions">
                <button class="jobs-panel__empty-action" onclick="focusUrlInputAndClose()">
                  ${t('jobsPanel.addUrl')}
                </button>
               <button class="jobs-panel__empty-action jobs-panel__empty-action--outline" onclick="focusFileInputAndClose()">
                  ${t('section.file')}
                </button>
              </div>
            </div>
          `;
          return;
        }

        list.innerHTML = items.map(j=>{
          const p = prog(j);
          let downloadLinks = '';

        if (j.status === 'completed') {
        if (typeof j.resultPath === 'string' && j.resultPath) {
          downloadLinks = `<a class="link" href="${j.resultPath}" download>${t('jobsPanel.downloadFile')}</a>`;
        }
        else if (Array.isArray(j.resultPath)) {
          const successfulResults = j.resultPath.filter(r => r.outputPath && !r.error);
          if (successfulResults.length > 0) {
            if (j.zipPath) {
              downloadLinks = `<a class="link" href="${j.zipPath}" download>${t('jobsPanel.downloadZip')}</a>`;
            } else {
              downloadLinks = `<span class="link" style="opacity:.8" title="${t('jobsPanel.multipleOutputs')}">${t('jobsPanel.multiple')}</span>`;
            }
          }
        }
        else if (typeof j.resultPath === 'object' && j.resultPath?.outputPath) {
          downloadLinks = `<a class="link" href="${j.resultPath.outputPath}" download>${t('jobsPanel.downloadFile')}</a>`;
        }
      }
          const baseTitle = titleOf(j);
          const nowT = nowTitle(j);
          const titleText = (j.metadata?.isPlaylist && nowT)
            ? `${baseTitle} ‚Äî ${nowT}`
            : (nowT || baseTitle);

          const skippedCount = computeSkippedPanel(j);
          const skippedKeywords = /(private|izin|skipp?ed|unavailable|atlan(?:d|an)|blocked|copyright|region|geo)/i;
          const showSkippedBadge =
            (skippedCount > 0) ||
            (j.lastLog && skippedKeywords.test(String(j.lastLog))) ||
            (j.lastLogKey && skippedKeywords.test(String(j.lastLogKey))) ||
            (j.error && skippedKeywords.test(String(j.error?.message || j.error)));
          const skippedBadge = showSkippedBadge
            ? `<span class="chip chip--warn" title="atlananlar">‚ö†Ô∏è ${t?.('jobs.skipped') || 'atlananlar'}${skippedCount ? ` (${skippedCount})` : ''}</span>`
            : '';

          return `
            <div class="job-card" data-job-id="${j.id}">
              <div class="job-title">${statusDot(j)}<span>${titleText}</span></div>

              <div class="job-meta">
              <span class="pill">${sourcePill(j)}</span>
              <span class="pill">${(j.format||'').toUpperCase()} ${j.bitrate||''}</span>
              ${j.sampleRate ? `<span class="pill">${Math.round(j.sampleRate / 1000)} kHz</span>` : ''}
              <span class="pill">${phasePill(j)}</span>
              ${skippedBadge}
            </div>

              ${(() => {
                const nt = nowT;
                return nt ? `<div class="muted" style="font-size:12px">‚ñ∂Ô∏è <strong>${nt}</strong></div>` : '';
              })()}

              <div class="progress panel" role="progressbar"
                   aria-valuemin="0" aria-valuemax="100" aria-valuenow="${p}">
                <span style="width:${p}%"></span>
              </div>

              <div class="row panel">
                <span>${p}%</span>
                <span style="display:flex; gap:8px; align-items:center;">
                  ${downloadLinks}
                  <button class="btn-danger" data-stop-panel="${j.id}" ${(['completed','error','canceled'].includes(norm(j.status))) ? 'disabled' : ''} title="${t('btn.stop')}">${t('btn.stop')}</button>
                </span>
              </div>
            </div>
          `;
        }).join('');

        try {
        list.querySelectorAll('[data-stop-panel]').forEach(btn=>{
          btn.onclick = async () => {
            const id = btn.getAttribute('data-stop-panel');
            btn.disabled = true;
            const j = state.items.find(x => x.id === id);
            const cb = j?.clientBatch || null;
            if (cb) {
              const sameBatch = state.items.filter(x => x.clientBatch === cb);
              try {
                await Promise.allSettled(sameBatch.map(x =>
                  fetch(`/api/jobs/${encodeURIComponent(x.id)}/cancel`, { method:'POST' })
                ));
                state.items = state.items.map(x =>
                  x.clientBatch === cb ? { ...x, status:'canceled', phase:'canceled' } : x
                );
                render();
                return;
                } catch(_) {
              }
            }
            try {
              const r = await fetch(`/api/jobs/${encodeURIComponent(id)}/cancel`, { method:'POST' });
              if (!r.ok) {
                const e = await r.json().catch(()=>({}));
                throw new Error(e?.error?.message || t('notif.cancelFailed'));
              }
              const idx = state.items.findIndex(j => j.id === id);
              if (idx >= 0) {
                state.items[idx] = { ...state.items[idx], status: 'canceled', phase: 'canceled' };
                render();
              }
            } catch(e) {
              btn.disabled = false;
            }
          };
        });
        } catch {}
      }

      function startSSE(){
        try {
          const token = localStorage.getItem(tokenKey) || "";
          es = new EventSource(`/api/stream?token=${encodeURIComponent(token)}`);
          es.onmessage = (ev) => {
            try {
              state = JSON.parse(ev.data) || { items: [] };
              render();
            } catch(e) {
              console.error('SSE parse error:', e);
            }
          };
          es.onerror = () => {
            try { es?.close?.(); } catch {}
            startPolling();
          };
        } catch(e) {
          console.error('SSE connection error:', e);
          startPolling();
        }
      }

      function startPolling(){
        const poll = () => {
          const token = localStorage.getItem(tokenKey) || "";
          fetch(`/api/jobs?status=all`, { headers: { 'Authorization': 'Bearer ' + token }})
            .then(r=>{
              if (!r.ok) throw new Error('Failed to fetch jobs');
              return r.json();
            })
            .then(d=>{
              state = { items: d.items || [] };
              render();
            })
            .catch(e=>{
              console.error('Polling error:', e);
            });
        };
        poll();
        setInterval(poll, 1500);
      }
    })();
    </script>
  </body>
</html>
